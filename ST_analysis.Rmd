---
title: "ST_analysis"
output: html_document
date: "2024-08-08"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load dependencies

```{r load libraries}
suppressMessages(library(Seurat))
suppressMessages(library(SeuratDisk))
suppressMessages(library(schard))
suppressMessages(library(tidyverse))
suppressMessages(library(dplyr))
suppressMessages(library(stringr))
suppressMessages(library(ggplot2))
suppressMessages(library(knitr))
suppressMessages(library(corrplot))
suppressMessages(library(CARD))
suppressMessages(library(SeuratDisk))
suppressMessages(library(patchwork))
suppressMessages(library(STutility))
suppressMessages(library(semla))
suppressMessages(library(GSVA))
suppressMessages(library(METAFlux))
suppressMessages(library(infercnv))
suppressMessages(library(ComplexHeatmap))
suppressMessages(library(biomaRt))
suppressMessages(library(SPOTlight))
suppressMessages(library(clusterProfiler))
suppressMessages(library(GSEABase))
suppressMessages(library(org.Hs.eg.db))
suppressMessages(library(enrichplot))
suppressMessages(library(ggchromatic))
suppressMessages(library(circlize))
suppressMessages(library(dendextend))
```

## BCSA1TumA1

```{r BCSA1TumA1}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA1TumA1.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.2)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 3)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.5, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA1TumA1_SCT.Rdata")

```

## BCSA1TumA2

```{r BCSA1TumA2}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA1TumA2.RData")

# Get the tissue coordinates
coords <- GetTissueCoordinates(bcsa)

# Coordinates for filtering cells that belong to the folded tissue area
x_min <- 344 * 0.2244921
x_max <- 1400 * 0.2244921
y_min <- 1250 * 0.2244921
y_max <- 1980 * 0.2244921

# Cells to remove that belong to the folded tissue area
cells_to_remove <- rownames(coords[coords$imagerow >= x_min & coords$imagerow <= x_max & 
                                     coords$imagecol >= y_min & coords$imagecol <= y_max, ])
  
# Subset the Seurat object based on the filtered coordinates
filtered_bcsa <- subset(bcsa, cells = setdiff(Cells(bcsa), cells_to_remove), invert=F)
SpatialDimPlot(filtered_bcsa, crop = F, pt.size.factor = 1)

# Filter the low quality spots and find highly variable genes
bcsa <- subset(filtered_bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.3)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 3)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA1TumA2_SCT.Rdata")

```

## BCSA1TumB1

```{r BCSA1TumB1}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA1TumB1.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.2)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(1, 2)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")

# Remove visium spots in empty space and re-do the clustering
bcsa <- subset(bcsa, seurat_clusters != "2")

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.2)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(1, 2)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA1TumB1_SCT.Rdata")

```

## BCSA1TumB2

```{r BCSA1TumB2}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA1TumB2.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.3)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 3)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA1TumB2_SCT.Rdata")

```

## BCSA1 integration

```{r BCSA1 integration}

load("~/Desktop/CIIR/results/colocalization/BCSA1TumA1_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumA1", Cells(bcsa), sep = "_"))
bcsaTuma1 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA1TumA2_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumA2", Cells(bcsa), sep = "_"))
bcsaTuma2 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA1TumB1_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumB1", Cells(bcsa), sep = "_"))
bcsaTumb1 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA1TumB2_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumB2", Cells(bcsa), sep = "_"))
bcsaTumb2 <- bcsa

# Merge replicates first, merge does not support merging 4 samples at a time
bcsaTuma <- merge(bcsaTuma1, bcsaTuma2)
bcsaTumb <- merge(bcsaTumb1, bcsaTumb2)
bcsa1 <- merge(bcsaTuma, bcsaTumb)

# split by original identity
ob_list <- SplitObject(bcsa1, split.by = "orig.ident")

ob_list <- lapply(ob_list, FUN = function(x) {
  x <- NormalizeData(x, normalization.method = "LogNormalize", scale.factor = 10000)
  x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 5000)
})

# select features that repeatedly variable across datasets for integration
features <- SelectIntegrationFeatures(object.list = ob_list) 

# For RPCA integration only
ob_list <- lapply(X = ob_list, FUN = function(x) {
    x <- ScaleData(x, features = features, verbose = FALSE)
    x <- RunPCA(x, features = features, verbose = FALSE)
})

anchors <- FindIntegrationAnchors(object.list = ob_list, anchor.features = features, reduction = "rpca")
bcsa1 <- IntegrateData(anchorset = anchors)

DefaultAssay(bcsa1) <- "integrated"

bcsa1 <- bcsa1 %>% 
  #FindVariableFeatures() %>% 
  ScaleData(vars.to.regress = "percent_mito") %>% 
  RunNMF(nfactors = 20) 
bcsa1 <- FindNeighbors(bcsa1, dims = 1:20, reduction = "NMF")
bcsa1 <- FindClusters(bcsa1, resolution = 0.4, cluster.name = "integrated_clusters") %>% 
  RunUMAP(dims = 1:20, reduction = "NMF", reduction.name = "umap")
DimPlot(bcsa1, reduction = "umap", group.by = c("orig.ident", "integrated_clusters"))

SpatialDimPlot(bcsa1, ncol = 2, alpha = 1)

################ Differential expression analysis to find markers
#cluster_markers <- FindAllMarkers(bcsa1, only.pos = T, test.use = "roc")
#markers <- cluster_markers %>% dplyr::group_by(cluster) %>% top_n(wt = power, 15)

cluster_markers_wilcox <- FindAllMarkers(bcsa1, only.pos = T, test.use = "wilcox") %>% 
  dplyr::group_by(cluster) %>% 
  top_n(wt = avg_log2FC, 50)

markers <- cluster_markers_wilcox %>% dplyr::group_by(cluster) %>% top_n(wt = avg_log2FC, 15)

col = c("0" = "#3C77AF",
        "1" = "#7DBFA7", "2" = "#EE934E", "4" = "#AECDE1",
        "3" = "#D1352B", "9" = "#F5CFE4", 
        "6" = "#FCED82", "5" = "#B383B9", "8" = "#BBDD78", "7" = "grey", "9" = "#429948")
SpatialDimPlot(bcsa1, group.by = "ident", ncol = 2, cols = col) + plot_layout(guides = "collect")
DimPlot(bcsa1, reduction = "umap", group.by = "orig.ident")
DimPlot(bcsa1, reduction = "umap", group.by = "integrated_clusters", cols = col)

# Plot the DEGs in each cluster
DoHeatmap(bcsa1, features = markers$gene, group.by = "ident",
          group.colors = col, slot = "scale.data", angle = 0, raster = F) 

# Percentage of each cluster in different tumor region
df <- table(bcsa1@meta.data$orig.ident, bcsa1@meta.data$integrated_clusters) %>% as.data.frame()
df <- df %>% group_by(Var1) %>% mutate(total = sum(Freq))
df$percent <- df$Freq / df$total
colnames(df)[2] <- "Clusters"

ggplot(df, aes(x = "", y = percent, fill = Clusters)) + geom_bar(stat = "identity") + 
  coord_polar("y", start = 0) + 
  theme_bw() + xlab("") + ylab("") +
  facet_wrap(~Var1) + scale_fill_manual(values = col)

# Rename Identity
bcsa1 <- RenameIdents(bcsa1, "0" = "Tumor", "1" = "Stroma-Tumor", "2" = "Tumor",
                      "3" = "Immune", "4" = "Low-density_area (Immune-mix)", "5" = "Tumor", "6" = "Tumor",
                      "7" = "Immune-Stroma", "8" = "Immune-Stroma", "9" = "Low-density_area (Stroma)")
bcsa1 <- AddMetaData(bcsa1, bcsa1@active.ident, col.name = "Annotated_clusters")

col = c("Tumor" = "#429948", "Stroma-Tumor" = "#BBDD78", "Immune-Stroma" = "#FCED82", 
         "Immune" = "#FFDE18", "Stroma" = "#9BCCE3", "Low-density_area (Stroma)" = "#9BCCE3",
         "Low-density_area (Immune-mix)" = "#D2817E")
SpatialDimPlot(bcsa1, group.by = "Annotated_clusters", ncol = 2, cols = col, 
               image.alpha = 0, pt.size.factor = 1.6) + plot_layout(guides = "collect")

################## Identify RegionNeighbors using semla package
# Update seurat object to be used in semla package
bcsa1 <- UpdateSeuratForSemla(bcsa1)

# Identify tumor edge by using inner mode
bcsa1 <- RegionNeighbors(bcsa1, column_name = "Annotated_clusters", column_labels = "Tumor",
                              mode = "inner")

# Identify neighbors next to tumor cluster
bcsa1 <- RegionNeighbors(bcsa1, column_name = "Annotated_clusters", column_labels = "Tumor")

# Identify neighbors within and next to tumor cluster
bcsa1 <- RegionNeighbors(bcsa1, column_name = "Annotated_clusters", column_labels = "Tumor",
                              mode = "all_inner_outer", column_key = "all_nb_to_")

#################### Check correlation between digital pathology and deconvolution on tumor edge

# Get the cell2location deconvolution results
decon <- data.frame()
for (i in names(bcsa1@images)) {
  temp1 <- read.csv(paste0("/Users/tili/Desktop/CIIR/results/cell2location/Merged_correlation_results/", 
                           i, "_correlation_matrix.csv"))
  region <- gsub("BCSA1", "", i)
  temp1$X <- paste0(region, "_", temp1$X)
  decon <- rbind(decon, temp1)
}

# Filter out the tumor edge spots
edge <- bcsa1@meta.data %>% 
  dplyr::select(orig.ident, Annotated_clusters, inner_border_Tumor) %>% 
  na.omit() %>% 
  mutate(cellid = rownames(.))

# Filter out spots next to tumor cluster
outside <- bcsa1@meta.data %>% 
  dplyr::select(orig.ident, Annotated_clusters, nb_to_Tumor) %>% 
  na.omit() %>% 
  mutate(cellid = rownames(.))

# Filter out spots within and outside tumor cluster
all_spot <- bcsa1@meta.data %>% 
  dplyr::select(orig.ident, Annotated_clusters, all_nb_to_Tumor) %>% 
  na.omit() %>% 
  mutate(cellid = rownames(.))
inner <- all_spot[-which(all_spot$cellid %in% edge$cellid | all_spot$cellid %in% outside$cellid),]

decon_edge <- decon[which(decon$X %in% edge$cellid),]
decon_inner <- decon[-which(decon$X %in% inner$cellid),]

# Correlation on tumor edge
p1 <- ggplot(decon_edge, aes(x = tumor_cel2, y = tumor_per)) + geom_point() + theme_bw() +
    ggtitle(paste0("Cell2location: Tumor edge correlation")) + geom_smooth(method = "lm") + 
  ggpubr::stat_cor(method = "spearman")

p2 <- ggplot(decon_inner, aes(x = tumor_cel2, y = tumor_per)) + geom_point() + theme_bw() +
    ggtitle(paste0("Cell2location: Tumor inner part correlation")) + geom_smooth(method = "lm") + 
  ggpubr::stat_cor(method = "spearman")
p1 + p2

################# Percentage of each cluster on the tumor edge

a1 <- decon_edge[which(str_detect(decon_edge$X, "TumA1")),] %>% 
  dplyr::select(X, immune_cel2, stroma_cel2, tumor_cel2, col_30p, row_30p_reverse) 
a1$col <- a1$col_30p * 0.2244921
a1$row_reverse <- a1$row_30p_reverse * 0.2244921

# Add HE image on the back
ima <- magick::image_read("/Users/tili/Desktop/CIIR/data/visium_spatial_out/V19T26-012_A1/tissue_hires_image.png")
image_in <- magick::image_info(ima)
width <- image_in$width
height <- image_in$height

# Plot the visium spots
p <- ggplot(a1, aes(y = row_reverse, x =col)) + 
  annotation_raster(ima, ymin = 0, ymax= height, xmin = 0, xmax = width) +
  geom_point() + theme_bw()

col = c("tumor_cel2" = "#429948", 
          "immune_cel2" = "#FFDE18", "stroma_cel2" = "#9BCCE3")

# Function to create pie charts as grobs
create_pie_grob <- function(pie_data) {
  pie <- ggplot(pie_data, aes(x = "", y = percent, fill = clusters)) +
    geom_bar(stat = "identity", width = 1) +
    coord_polar("y") +
    theme_void() + scale_fill_manual(values = col) +
    theme(legend.position = "none")  # Remove legend for simplicity
  grob <- ggplotGrob(pie)
  return(grob)
}

# Add pie charts to the scatter plot
for (i in 1:nrow(a1)) {
  temp1 <- a1[i, 1:4] %>% as.data.frame() %>% 
    pivot_longer(!X, names_to = "clusters", values_to = "percent")
  # Remove the spotid column for correct plotting
  temp1 <- temp1[,-1]
  pie_grob <- create_pie_grob(temp1)
  p <- p + annotation_custom(pie_grob, xmin = a1$col[i] - 8, xmax = a1$col[i] + 8,
                             ymin = a1$row_reverse[i] - 8, ymax = a1$row_reverse[i] + 8)
}
print(p)

################## Check what cluster is next to each tumor cluster

# Identify neighbors next to tumor cluster
bcsa1 <- RegionNeighbors(bcsa1, column_name = "integrated_clusters", column_labels = "0", 
                         column_key = "nb_to_tumor_", mode = "inner")
bcsa1 <- RegionNeighbors(bcsa1, column_name = "integrated_clusters", column_labels = "2", 
                         column_key = "nb_to_tumor_", mode = "inner")
bcsa1 <- RegionNeighbors(bcsa1, column_name = "integrated_clusters", column_labels = "5", 
                         column_key = "nb_to_tumor_", mode = "inner")
bcsa1 <- RegionNeighbors(bcsa1, column_name = "integrated_clusters", column_labels = "6", 
                         column_key = "nb_to_tumor_", mode = "inner")

# Get the cell2location deconvolution results and merge them into one dataframe
temp1 <- data.frame()
for (i in names(bcsa1@images)) {
  temp1.cel2 <- read.csv(paste0("/Users/tili/Desktop/CIIR/results/cell2location/", 
                           i, "_q05.csv"))
  colnames(temp1.cel2) <- gsub("q05cell_abundance_w_sf_", "", colnames(temp1.cel2))
  
  # Normalize cell type proportion so that the proportion adds up to 1
  temp1.cell2 <- rowSums(temp1.cel2[,-1]) %>% as.data.frame() %>% 'colnames<-' ("RowSum")
  temp1.cell2$X <- temp1.cel2$X
  for (k in 2:ncol(temp1.cel2)) {
    temp1.cell2[,k+1] <- temp1.cel2[,k] / temp1.cell2$RowSum
    colnames(temp1.cell2)[k+1] <- colnames(temp1.cel2)[k]
  }
  temp1.cel2 <- temp1.cell2[,-1]
  
  sec_id <- gsub("BCSA1", "", i)
  rownames(temp1.cel2) <- paste0(sec_id, "_", temp1.cel2$X)
  temp1.cel2 <- temp1.cel2[,-1]
  
  temp1 <- rbind(temp1, temp1.cel2)
}

nb <- bcsa1@meta.data %>% dplyr::select(nb_to_tumor_0, nb_to_tumor_2, nb_to_tumor_5, nb_to_tumor_6)
nb$spotid <- rownames(nb)

# Filter out tumor 1 neighbors
t0_nb <- nb[,c(1,5)] %>% na.omit()
t0 <- temp1[which(rownames(temp1) %in% t0_nb$spotid),]

# Plot colocalization/interactions
SPOTlight::plotInteractions(as.matrix(t0), which = "network")

# Filter out tumor 2 neighbors
t2_nb <- nb[,c(2,5)] %>% na.omit()
t2 <- temp1[which(rownames(temp1) %in% t2_nb$spotid),]

# Plot colocalization/interactions
SPOTlight::plotInteractions(as.matrix(t2), which = "network")

# Filter out tumor 5 neighbors
t5_nb <- nb[,c(3,5)] %>% na.omit()
t5 <- temp1[which(rownames(temp1) %in% t5_nb$spotid),]

# Plot colocalization/interactions
SPOTlight::plotInteractions(as.matrix(t5), which = "network")

# Filter out tumor 7 neighbors
t6_nb <- nb[,c(4,5)] %>% na.omit()
t6 <- temp1[which(rownames(temp1) %in% t6_nb$spotid),]

# Plot colocalization/interactions
SPOTlight::plotInteractions(as.matrix(t6), which = "network")

p1 <- t1 %>% mutate(spotid = rownames(.)) %>% 
  pivot_longer(!spotid, names_to = "predicted_celltype", values_to = "percent") %>% 
  ggplot(aes(x = predicted_celltype, y = log2(percent), fill = predicted_celltype)) + geom_violin() + 
  theme_bw() + #geom_boxplot(width = 0.1) +
  ggtitle("Neighbors to Tumor Cluster 1") + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + xlab("")

p2 <- t2 %>% mutate(spotid = rownames(.)) %>% 
  pivot_longer(!spotid, names_to = "predicted_celltype", values_to = "percent") %>% 
  ggplot(aes(x = predicted_celltype, y = log2(percent), fill = predicted_celltype)) + geom_violin() + 
  theme_bw() + #geom_boxplot(width = 0.1) +
  ggtitle("Neighbors to Tumor Cluster 2") + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + xlab("")

p3 <- t5 %>% mutate(spotid = rownames(.)) %>% 
  pivot_longer(!spotid, names_to = "predicted_celltype", values_to = "percent") %>% 
  ggplot(aes(x = predicted_celltype, y = log2(percent), fill = predicted_celltype)) + geom_violin() + 
  theme_bw() + #geom_boxplot(width = 0.1) +
  ggtitle("Neighbors to Tumor Cluster 5") + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + xlab("")

p4 <- t7 %>% mutate(spotid = rownames(.)) %>% 
  pivot_longer(!spotid, names_to = "predicted_celltype", values_to = "percent") %>% 
  ggplot(aes(x = predicted_celltype, y = log2(percent), fill = predicted_celltype)) + geom_violin() + 
  theme_bw() + #geom_boxplot(width = 0.1) +
  ggtitle("Neighbors to Tumor Cluster 7") + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + xlab("")

p1 + p2 + p3 + p4 + plot_layout(guides = "collect")

################## GSVA on the sub-clusters

Idents(bcsa1) <- bcsa1@meta.data$integrated_clusters

# Aggregate expression in each cluster
pseudo_bcsa1 <- AggregateExpression(bcsa1, assays = "Spatial", return.seurat = T, group.by = "integrated_clusters")

# Extract data matrix from the counts slot
pseudo_matrix <- GetAssayData(pseudo_bcsa1, assay = "Spatial", layer = "counts") %>% as.data.frame()

# Normalization
normalized_pseudo <- edgeR::cpm(pseudo_matrix, normalized.lib.sizes = T, log = T)

# Hallmark gene set
geneset <- GSEABase::getGmt("/Users/tili/Desktop/CIIR/data/h.all.v2024.1.Hs.symbols.gmt")

# GSVA analysis
# kcdf value "Gaussian" is suitable for continuous expression data, such as microarray fluorescent units in logarithmic scale and 
# RNA-seq log-CPMs, log-RPKMs or log-TPMs units of expression; "Poisson" is suitable for integer counts, such as those 
# derived from RNA-seq alignments
gsvaPar <- gsvaParam(as.matrix(normalized_pseudo), geneset, kcdf = "Gaussian")
gsva.es <- gsva(gsvaPar, verbose=FALSE)

Heatmap(gsva.es,
        cluster_columns = T,
        cluster_rows = T,
        show_row_names = T,
        show_column_names = T,
        clustering_distance_rows = "euclidean",
        color = colorRampPalette(c("blue", "white", "red"))(100))

######################### DE analysis on different tumor clusters

Idents(bcsa1) <- bcsa1@meta.data$integrated_clusters
t0_vs_t2 <- FindMarkers(bcsa1, ident.1 = "0", ident.2 = "2")
t0_vs_t2$gene <- rownames(t0_vs_t2)

# Get entrez id
entrez <- clusterProfiler::bitr(rownames(t0_vs_t2), fromType = "SYMBOL", 
                                         toType = "ENTREZID", OrgDb = org.Hs.eg.db)
t0_vs_t2 <- merge(t0_vs_t2, entrez, by.x = "gene", by.y = "SYMBOL", all.x = F)

# Create a genelist for gseGO analysis
genelist <- t0_vs_t2$avg_log2FC
names(genelist) <- t0_vs_t2$ENTREZID
genelist <- sort(genelist, decreasing = T)

# gseGO analysis
go <- gseGO(genelist, ont = "BP", OrgDb = org.Hs.eg.db, 
            keyType = "ENTREZID", minGSSize = 10, maxGSSize = 500,
            pvalueCutoff = 0.05, pAdjustMethod = "BH")
go <- setReadable(go, OrgDb = org.Hs.eg.db,keyType = "ENTREZID")

# Plot gseGO results, cluster the top30 GOs
go2 <- enrichplot::pairwise_termsim(go)
treeplot(go2, showCategory = 30, color = "NES") + ggtitle("BCSA1 Tumor 0 vs 2") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4, 4))
openxlsx::write.xlsx(go2@result, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA1_tumor_cluster_0_vs_2_gseGO_20241016.xlsx")

### t0 vs t5 cluster
t0_vs_t5 <- FindMarkers(bcsa1, ident.1 = "0", ident.2 = "5")
t0_vs_t5$gene <- rownames(t0_vs_t5)

# Get entrez id
entrez <- clusterProfiler::bitr(rownames(t0_vs_t5), fromType = "SYMBOL", 
                                         toType = "ENTREZID", OrgDb = org.Hs.eg.db)
t0_vs_t5 <- merge(t0_vs_t5, entrez, by.x = "gene", by.y = "SYMBOL", all.x = F)

# Create a genelist for gseGO analysis
genelist <- t0_vs_t5$avg_log2FC
names(genelist) <- t0_vs_t5$ENTREZID
genelist <- sort(genelist, decreasing = T)

# gseGO analysis
go <- gseGO(genelist, ont = "BP", OrgDb = org.Hs.eg.db, 
            keyType = "ENTREZID", minGSSize = 10, maxGSSize = 500,
            pvalueCutoff = 0.05, pAdjustMethod = "BH")
go <- setReadable(go, OrgDb = org.Hs.eg.db,keyType = "ENTREZID")

# Plot gseGO results, cluster the top30 GOs
go2 <- pairwise_termsim(go)
treeplot(go2, showCategory = 30, color = "NES") + ggtitle("BCSA1 Tumor 0 vs 5") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4, 4))
openxlsx::write.xlsx(go2@result, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA1_tumor_cluster_0_vs_5_gseGO_20241016.xlsx")

### t0 vs t6 cluster
t0_vs_t6 <- FindMarkers(bcsa1, ident.1 = "0", ident.2 = "6")
t0_vs_t6$gene <- rownames(t0_vs_t6)

# Get entrez id
entrez <- clusterProfiler::bitr(rownames(t0_vs_t6), fromType = "SYMBOL", 
                                         toType = "ENTREZID", OrgDb = org.Hs.eg.db)
t0_vs_t6 <- merge(t0_vs_t6, entrez, by.x = "gene", by.y = "SYMBOL", all.x = F)

# Create a genelist for gseGO analysis
genelist <- t0_vs_t6$avg_log2FC
names(genelist) <- t0_vs_t6$ENTREZID
genelist <- sort(genelist, decreasing = T)

# gseGO analysis
go <- gseGO(genelist, ont = "BP", OrgDb = org.Hs.eg.db, 
            keyType = "ENTREZID", minGSSize = 10, maxGSSize = 500,
            pvalueCutoff = 0.05, pAdjustMethod = "BH")
go <- setReadable(go, OrgDb = org.Hs.eg.db,keyType = "ENTREZID")

# Plot gseGO results, cluster the top30 GOs
go2 <- pairwise_termsim(go)
treeplot(go2, showCategory = 30, color = "NES") + ggtitle("BCSA1 Tumor 0 vs 6") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4, 4))
openxlsx::write.xlsx(go2@result, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA1_tumor_cluster_0_vs_6_gseGO_20241016.xlsx")

### t2 vs t5 cluster
t2_vs_t5 <- FindMarkers(bcsa1, ident.1 = "2", ident.2 = "5")
t2_vs_t5$gene <- rownames(t2_vs_t5)

# Get entrez id
entrez <- clusterProfiler::bitr(rownames(t2_vs_t5), fromType = "SYMBOL", 
                                         toType = "ENTREZID", OrgDb = org.Hs.eg.db)
t2_vs_t5 <- merge(t2_vs_t5, entrez, by.x = "gene", by.y = "SYMBOL", all.x = F)

# Create a genelist for gseGO analysis
genelist <- t2_vs_t5$avg_log2FC
names(genelist) <- t2_vs_t5$ENTREZID
genelist <- sort(genelist, decreasing = T)

# gseGO analysis
go <- gseGO(genelist, ont = "BP", OrgDb = org.Hs.eg.db, 
            keyType = "ENTREZID", minGSSize = 10, maxGSSize = 500,
            pvalueCutoff = 0.05, pAdjustMethod = "BH")
go <- setReadable(go, OrgDb = org.Hs.eg.db,keyType = "ENTREZID")

# Plot gseGO results, cluster the top30 GOs
go2 <- pairwise_termsim(go)
treeplot(go2, showCategory = 30, color = "NES") + ggtitle("BCSA1 Tumor 2 vs 5") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4, 4))
openxlsx::write.xlsx(go2@result, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA1_tumor_cluster_2_vs_5_gseGO_20241016.xlsx")

### t2 vs t6
t2_vs_t6 <- FindMarkers(bcsa1, ident.1 = "2", ident.2 = "6")
t2_vs_t6$gene <- rownames(t2_vs_t6)

# Get entrez id
entrez <- clusterProfiler::bitr(rownames(t2_vs_t6), fromType = "SYMBOL", 
                                         toType = "ENTREZID", OrgDb = org.Hs.eg.db)
t2_vs_t6 <- merge(t2_vs_t6, entrez, by.x = "gene", by.y = "SYMBOL", all.x = F)

# Create a genelist for gseGO analysis
genelist <- t2_vs_t6$avg_log2FC
names(genelist) <- t2_vs_t6$ENTREZID
genelist <- sort(genelist, decreasing = T)

# gseGO analysis
go <- gseGO(genelist, ont = "BP", OrgDb = org.Hs.eg.db, 
            keyType = "ENTREZID", minGSSize = 10, maxGSSize = 500,
            pvalueCutoff = 0.05, pAdjustMethod = "BH")
go <- setReadable(go, OrgDb = org.Hs.eg.db,keyType = "ENTREZID")

# Plot gseGO results, cluster the top30 GOs
go2 <- pairwise_termsim(go)
treeplot(go2, showCategory = 30, color = "NES") + ggtitle("BCSA1 Tumor 2 vs 6") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4, 4))
openxlsx::write.xlsx(go2@result, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA1_tumor_cluster_2_vs_6_gseGO_20241016.xlsx")

### t5 vs t6 cluster
t5_vs_t6 <- FindMarkers(bcsa1, ident.1 = "5", ident.2 = "6")
t5_vs_t6$gene <- rownames(t5_vs_t6)

# Get entrez id
entrez <- clusterProfiler::bitr(rownames(t5_vs_t6), fromType = "SYMBOL", 
                                         toType = "ENTREZID", OrgDb = org.Hs.eg.db)
t5_vs_t6 <- merge(t5_vs_t6, entrez, by.x = "gene", by.y = "SYMBOL", all.x = F)

# Create a genelist for gseGO analysis
genelist <- t5_vs_t6$avg_log2FC
names(genelist) <- t5_vs_t6$ENTREZID
genelist <- sort(genelist, decreasing = T)

# gseGO analysis
go <- gseGO(genelist, ont = "BP", OrgDb = org.Hs.eg.db, 
            keyType = "ENTREZID", minGSSize = 10, maxGSSize = 500,
            pvalueCutoff = 0.05, pAdjustMethod = "BH")
go <- setReadable(go, OrgDb = org.Hs.eg.db,keyType = "ENTREZID")

# Plot gseGO results, cluster the top30 GOs
go2 <- pairwise_termsim(go)
treeplot(go2, showCategory = 30, color = "NES") + ggtitle("BCSA1 Tumor 5 vs 6") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4, 4))
openxlsx::write.xlsx(go2@result, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA1_tumor_cluster_5_vs_6_gseGO_20241016.xlsx")

# Save Seurat object
save(bcsa1, cluster_markers_wilcox, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA1_merge.Rdata")

########################### UMAP colored by QuPath annotation ###############

umap_em <- bcsa1@reductions$umap@cell.embeddings %>% as.data.frame()
umap_em$spotid <- rownames(umap_em)

# Merge UMAP coordinates with QuPath classification results
umap_em <- merge(umap_em, decon, by.x = "spotid", by.y = "X", all.x = F, all.y = T)

# Plot UMAP
tumor_color <- "#D2817E"  # Custom reddish color
immune_color <- "#FFDE18" # Custom yellowish color
stroma_color <- "#9BCCE3" # Custom bluish color

# Create a color ramp function for each custom color
tumor_ramp <- colorRamp(c("black", tumor_color))
immune_ramp <- colorRamp(c("black", immune_color))
stroma_ramp <- colorRamp(c("black", stroma_color))

# Blend custom colors based on the proportions
umap_em$custom_color <- apply(
  umap_em[, c("tumor_per", "immune_per", "stroma_per")], 1, function(row) {
    # Weighted blending of tumor, immune, and stroma colors
    blended <- tumor_ramp(row["tumor_per"]) +
               immune_ramp(row["immune_per"]) +
               stroma_ramp(row["stroma_per"])
    blended <- blended / max(blended) * 255  # Normalize to keep within 0–255 range
    rgb(blended[1] / 255, blended[2] / 255, blended[3] / 255) # Convert to hex
  }
)

# Plot the UMAP with the custom blended colors
ggplot(umap_em, aes(x = umap_1, y = umap_2, col = custom_color)) +
  geom_point(size = 0.3) + 
  scale_colour_identity() +
  new_scale_color() +
  geom_point(aes(col = tumor_per), shape = NA) +
  scale_color_gradient(low = "black", high = "#D2817E") +
  new_scale_color() +
  geom_point(aes(col = immune_per), shape = NA) +
  scale_color_gradient(low = "black", high = "#FFDE18") +
  new_scale_color() +
  geom_point(aes(col = stroma_per), shape = NA) +
  scale_color_gradient(low = "black", high = "#9BCCE3") +
  new_scale_color() + theme_bw() +
  xlab("UMAP1") + ylab("UMAP2")

```

## BCSA1 QuPath cell percentage in different tumor clusters

```{r QuPath cell percent in tumor clusters}

qupath <- read.csv("/Users/tili/Desktop/CIIR/results/Cell_annotation_qupath_analyzed/cell_qupath_combined_20241014.csv")
qupath$spot <- paste0(str_sub(qupath$id, start = 6), "_", qupath$cellid)
qupath$patient <- str_sub(qupath$id, end = 5)

# Extract tumor spot id
df <- bcsa1@meta.data %>% dplyr::select(orig.ident, integrated_clusters)

# Filter out spot id for tumor clusters
#spotid <- df[which(df$integrated_clusters == 6 | df$integrated_clusters == 0 | 
#                        df$integrated_clusters == 5 | df$integrated_clusters == 2),]

# Take spot id from all clusters
spotid <- df
spotid$spot <- rownames(spotid)

bcsa1_tumor <- qupath[which(qupath$spot %in% spotid$spot & qupath$patient == "BCSA1"),]
bcsa1_tumor <- merge(bcsa1_tumor, spotid, by.x = "spot", by.y = "spot")

# Calculate the percent of tumor, immune, and stroma in each cluster
bcsa1_freq <- bcsa1_tumor %>% dplyr::group_by(integrated_clusters) %>% 
  dplyr::count(Classification) %>% 
  dplyr::filter(Classification != "")

bcsa1_freq <- bcsa1_freq %>% dplyr::group_by(integrated_clusters) %>% mutate(Total = sum(n))
bcsa1_freq$Percent <- bcsa1_freq$n / bcsa1_freq$Total
bcsa1_freq$Cluster <- paste0("Cluster", bcsa1_freq$integrated_clusters)

bcsa1_freq$spot_n <- rep(table(bcsa1@meta.data$integrated_clusters), each = 3)
bcsa1_freq$spot_density <- round(bcsa1_freq$Total / bcsa1_freq$spot_n, 2)

# Plot the cell type percent in each tumor cluster
ggplot(bcsa1_freq, aes(x = Cluster, y = Percent, fill = Classification)) + 
  geom_bar(stat = "identity", position = "stack") + theme_bw() +
  scale_fill_manual(values = c("Tumor" = "#429948", 
          "Immune cells" = "#FFDE18", "Stroma" = "#9BCCE3")) + xlab("") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

## BCSA1 Metabolic score estimation with METAFlux

```{r METAFlux estimation}

# Perform metabolic score estimation on pseudobulk aggregate samples
# The gene expression matrix should be gene x sample matrix where row names are human gene names (gene symbols), and column names should be sample names. Please note that METAFlux does not support other gene IDs.
# The input gene expression matrix should be normalized (e.g., log-transformed, etc.) before using METAFlux. METAflux will not perform any normalization on expression data.
# Gene expression data cannot have negative values.
normalized_pseudo <- edgeR::cpm(pseudo_matrix, normalized.lib.sizes = T, log = F)
log_pseudo <- log2(normalized_pseudo + 1)

# We used Human-GEM (consisting of 13082 metabolic reactions and 8378 metabolites) as our underlying metabolic model
data("human_gem")

# In METAFlux, ‘medium’ reflects the nutrients (metabolites) in the sample tumor microenvironment (TME) and those nutrients can be allowed to uptake into cells.
data("human_blood")# for human derived samples

# Calculate a single sample normalized MRAS (Metabolic Reaction Activity Score) from gene expression using GPR (Gene-protein-reaction).
scores <- calculate_reaction_score(log_pseudo)

# Calculate the metabolic fluxes for the 13082 reactions
flux <- compute_flux(mras=scores, medium = human_blood)

# Apply cubic root normalization to flux scores.
cbrt <- function(x) {
    sign(x) * abs(x)^(1/3)
}

flux <- cbrt(flux)

# Search “nutrient lookup file” to obtain the metabolite exchange Reaction ID
data("nutrient_lookup_files")

# “Sign” of flux indicates the direction. For example, for the nutrient uptake/release case (1648 exchange reactions in nutrient lookup file), a positive value means a release of compounds, and a negative value means uptake of compounds.
glucose <- flux[human_gem[str_detect(human_gem$SUBSYSTEM, "Glycolysis"),]$ID,]
ComplexHeatmap::Heatmap(glucose, cluster_rows = T,
                        cluster_columns = T,
                        show_row_names = T,
                        show_column_names = T,
                        clustering_distance_rows = "euclidean",
                        color = colorRampPalette(c("blue", "white", "red"))(100))

cholesterol <- flux[human_gem[str_detect(human_gem$SUBSYSTEM, "Cholesterol"),]$ID,]
ComplexHeatmap::Heatmap(cholesterol, cluster_rows = T,
                        cluster_columns = T,
                        show_row_names = T,
                        show_column_names = T,
                        clustering_distance_rows = "euclidean",
                        color = colorRampPalette(c("blue", "white", "red"))(100))

```

## Plot BCSA1 inferCNV results

```{r BCSA1 inferCNV}

cnv <- readRDS("/Users/tili/Desktop/CIIR/results/infercnv/BCSA1_i3/run.final.scaled.infercnv_obj")

# infercnv_obj@expr.data is the scaled cnv number for each dot in column and gene in row;
# infercnv_obj@gene_order is the gene location, chr, start and end.

bcsa1_cnv_matrix <- cnv@expr.data
gene_order <- cnv@gene_order
gene_order$gene <- rownames(gene_order)

meta <- bcsa1@meta.data %>% dplyr::select(integrated_clusters, orig.ident)
meta$spotid <- rownames(meta)
meta <- meta[which(meta$spotid %in% colnames(bcsa1_cnv_matrix)),]

col = c("0" = "#3C77AF",
        "1" = "#7DBFA7", "2" = "#EE934E", "4" = "#AECDE1",
        "3" = "#D1352B", "9" = "#F5CFE4", 
        "6" = "#FCED82", "5" = "#B383B9", "8" = "#BBDD78", "7" = "grey", "9" = "#429948")
ha <- HeatmapAnnotation(Cluster = meta$integrated_clusters, col = list(Cluster = col))

col_fun <- colorRamp2(
  breaks = c(0.8, 1, 1.2),  # Values to map
  colors = c("blue", "white", "red")  # Colors corresponding to the values
)

# Cluster by column (integrated clusters)
Heatmap(bcsa1_cnv_matrix, cluster_rows = F, 
        show_row_names = F, show_column_names = F,
        row_split = gene_order$chr, 
        top_annotation = ha, col = col_fun, 
        column_split = meta$integrated_clusters, cluster_column_slices = T)

# Save results
write.csv(bcsa1_cnv_matrix, file = "/Users/tili/Desktop/CIIR/results/infercnv/BCSA1_i3/bcsa1_cnv_matrix.csv")
write.csv(gene_order, file = "/Users/tili/Desktop/CIIR/results/infercnv/BCSA1_i3/gene_order.csv")

# Extract meta data
normal <- read.delim("/Users/tili/Desktop/CIIR/results/infercnv/BCSA1_ref_spot.txt", header = F)
normal$type <- rep("Normal", nrow(normal))
tumor <- read.delim("/Users/tili/Desktop/CIIR/results/infercnv/BCSA1_filtered_tumor_40_percent_spots_rep1_for_inferCNV.txt", header = F)
tumor$type <- rep("Tumor", nrow(tumor))
spots <- rbind(normal, tumor)
spots <- spots[which(spots$V1 %in% colnames(bcsa1_cnv_matrix)),]

tumor_matrix <- bcsa1_cnv_matrix[, which(colnames(bcsa1_cnv_matrix) %in% tumor$V1)]

# Cluster by clone
hm <- Heatmap(tumor_matrix, cluster_rows = F, 
        show_row_names = F, show_column_names = F, cluster_columns = T,
        col = col_fun, 
        border = T,
        clustering_method_columns = "ward.D",
        row_split = gene_order$chr
        )

# Extract dendrogram for each cluster
col_order_list <- column_dend(hm)

# Cut tree at height 150 to get 3 clusters
dend1 <- col_order_list[[1]]
clone1 <- cutree(dend1, h = 95)

dend2 <- col_order_list[[2]]
temp1 <- cutree(dend2, h = 95) %>% as.data.frame()
temp1$cluster <- ifelse(str_detect(temp1$., "1"), 3, 4)
clone2 <- temp1$cluster
names(clone2) <- rownames(temp1)

clone <- c(clone1, clone2)

# Add results to bcsa meta data
bcsa <- subset(bcsa1, orig.ident %in% c("BCSA1TumA1", "BCSA1TumB1"))
bcsa <- subset(bcsa, cells = names(clone))
bcsa <- AddMetaData(bcsa, clone, col.name = "inferCNV")
co <- c("1" = "#35A153", "2" = "#FFCD44", "3" = "#1d9bf7", "4" = "#d95f0e")
SpatialDimPlot(bcsa, group.by = "inferCNV", pt.size.factor = 1, cols = co)

# Plot heatmap with clone information
clones <- as.data.frame(clone)
clones$spotid <- rownames(clones)
clones <- merge(clones, meta, by.x = "spotid", by.y = "spotid", all.x = T, all.y = F)
ha <- HeatmapAnnotation(Cluster = clones$integrated_clusters, col = list(Cluster = col))
ba <- HeatmapAnnotation(Clone = clones$clone, col = list(Clone = co))
Heatmap(tumor_matrix, cluster_rows = F, 
        show_row_names = F, show_column_names = F, cluster_columns = T,
        col = col_fun, 
        column_split = clones$clone,
        top_annotation = ha,
        bottom_annotation = ba,
        clustering_method_columns = "ward.D",
        row_split = gene_order$chr
        )

```

## BCSA1 PAM50

```{r BCSA1 PAM50}

# load PAM50 results
load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA1TumA1_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumA1", Cells(bcsa), sep = "_"))
bcsaTuma1 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA1TumA2_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumA2", Cells(bcsa), sep = "_"))
bcsaTuma2 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA1TumB1_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumB1", Cells(bcsa), sep = "_"))
bcsaTumb1 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA1TumB2_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumB2", Cells(bcsa), sep = "_"))
bcsaTumb2 <- bcsa

# Merge replicates first, merge does not support merging 4 samples at a time
bcsaTuma <- merge(bcsaTuma1, bcsaTuma2)
bcsaTumb <- merge(bcsaTumb1, bcsaTumb2)

bcsa1_pam50 <- merge(bcsaTuma, bcsaTumb)

# Aggregate deconvolution results
temp1 <- data.frame()
for (i in names(bcsa1@images)) {
  temp1.cel2 <- read.csv(paste0("/Users/tili/Desktop/CIIR/results/cell2location/", i, "_q05.csv"))
  colnames(temp1.cel2) <- gsub("q05cell_abundance_w_sf_", "", colnames(temp1.cel2))
  
  # Normalize cell type proportion so that the proportion adds up to 1
  temp1.cell2 <- rowSums(temp1.cel2[,-1]) %>% as.data.frame() %>% 'colnames<-' ("RowSum")
  temp1.cell2$X <- temp1.cel2$X
  for (k in 2:ncol(temp1.cel2)) {
    temp1.cell2[,k+1] <- temp1.cel2[,k] / temp1.cell2$RowSum
    colnames(temp1.cell2)[k+1] <- colnames(temp1.cel2)[k]
  }
  temp1.cel2 <- temp1.cell2[,-1]
  region <- gsub("BCSA1", "", i)
  temp1.cel2$X <- paste0(region, "_", temp1.cel2$X)
  temp1 <- rbind(temp1, temp1.cel2)
}

# Aggregate epithelial clusters
temp1$epithelial <- rowSums(temp1[which(str_detect(colnames(temp1), 
                                      "Cancer|Mature.Luminal|Luminal.Progenitors|Myoepithelial"))])

# Filter out spots does not have 20% of epithelial
temp1_filtered <- temp1[which(temp1$epithelial > 0.2), ]

pam50 <- bcsa1_pam50@meta.data$subtypecd_aims
names(pam50) <- rownames(bcsa1_pam50@meta.data)

# Keep spots that are only used in the clustering and with at least 20% of epithelial cells
pam50 <- pam50[which(names(pam50) %in% temp1_filtered$X)]
pam50 <- pam50[which(names(pam50) %in% colnames(bcsa1))]

bcsa1_pam50 <- bcsa1
bcsa1_pam50 <- AddMetaData(bcsa1_pam50, pam50, col.name = "PAM50_aims")

# Subset the seurat object
temp1_filtered <- temp1_filtered[which(temp1_filtered$X %in% colnames(bcsa1)),]
bcsa1_pam50 <- subset(bcsa1_pam50, cells = temp1_filtered$X)

# Filter out spots without tumor based on QuPath annotation
ref <- read.delim("/Users/tili/Desktop/CIIR/results/infercnv/BCSA1_ref_spot.txt", header = F)
temp1_tumor <- temp1_filtered[-which(temp1_filtered$X %in% ref$V1),]

# Subset the seurat object
bcsa1_pam50 <- subset(bcsa1_pam50, cells = temp1_tumor$X)

#colpam50 <- c("#74a0c4", "#B3CDE3", "#FED9A6", "#FBB4AE", "#ccebc5")
col <- c("NBL" = "#66c530", "H2" = "#d4279c", "LA" = "#2a3188", "LB" = "#419ad2", "BL" = "#97191e")
SpatialDimPlot(bcsa1_pam50, group.by = "PAM50_aims", ncol = 4, cols = col) + 
  plot_layout(guides = "collect")

# Pie chart for PAM50 percent
df <- table(bcsa1_pam50@meta.data$PAM50_aims) %>% as.data.frame()
df$Total <- sum(df$Freq)
df$Percent <- df$Freq / df$Total

pie(df$Freq, labels = paste(df$Var1, round(df$Percent * 100, 2), "%"), 
    col = c("BL" = "#97191e", "H2" = "#d4279c", "NBL" = "#66c530"), main = "BCSA1 PAM50")

############## Calculate the percentage of each cluster in each intrinsic subtype
meta <- bcsa1_pam50@meta.data %>% as.data.frame() 
cluster_freq <- meta %>% dplyr::group_by(PAM50_aims) %>% 
  dplyr::count(integrated_clusters)

cluster_freq <- cluster_freq %>% dplyr::group_by(PAM50_aims) %>% mutate(Total = sum(n))
cluster_freq$Percent <- cluster_freq$n / cluster_freq$Total

ggplot(cluster_freq, aes(x = PAM50_aims, y = Percent, fill = integrated_clusters)) + 
  geom_bar(stat = "identity", position = "stack") + theme_bw() +
  scale_fill_manual(values = c("0" = "#3C77AF",
        "1" = "#7DBFA7", "2" = "#EE934E", "4" = "#AECDE1",
        "3" = "#D1352B", "9" = "#F5CFE4", 
        "6" = "#FCED82", "5" = "#B383B9", "8" = "#BBDD78", "7" = "grey", "9" = "#429948")) + xlab("") 

########## Plot the cell type percent from QuPath
qupath <- read.csv("/Users/tili/Desktop/CIIR/results/Cell_annotation_qupath_analyzed/cell_qupath_combined_20241014.csv")
qupath$spot <- paste0(str_sub(qupath$id, start = 6), "_", qupath$cellid)
qupath$patient <- str_sub(qupath$id, end = 5)

# Extract tumor spot id
spotid <- bcsa1_pam50@meta.data %>% as.data.frame()
spotid$X <- rownames(spotid)

bcsa1_filtered <- qupath[which(qupath$spot %in% spotid$X & qupath$patient == "BCSA1"),]
bcsa1_filtered <- merge(bcsa1_filtered, spotid, by.x = "spot", by.y = "X")

# Calculate the percent of tumor, immune, and stroma in intrinsic subtype
bcsa1_freq <- bcsa1_filtered %>% dplyr::group_by(PAM50_aims) %>% 
  dplyr::count(Classification) %>% 
  dplyr::filter(Classification != "")

bcsa1_freq <- bcsa1_freq %>% dplyr::group_by(PAM50_aims) %>% mutate(Total = sum(n))
bcsa1_freq$Percent <- bcsa1_freq$n / bcsa1_freq$Total

# Plot the cell type percent in each tumor cluster
ggplot(bcsa1_freq, aes(x = PAM50_aims, y = Percent, fill = Classification)) + 
  geom_bar(stat = "identity", position = "stack") + theme_bw() +
  scale_fill_manual(values = c("Tumor" = "#429948", 
          "Immune cells" = "#FFDE18", "Stroma" = "#9BCCE3")) + xlab("") 

```

## BCSA1 TumA1 cell type markers and deconvolution

```{r BCSA1TumA1 cell type markers and deconvolution}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA1TumA1_processed.RData")

temp1.cel2 <- read.csv("/Users/tili/Desktop/CIIR/results/cell2location/BCSA1TumA1_q05.csv")
colnames(temp1.cel2) <- gsub("q05cell_abundance_w_sf_", "", colnames(temp1.cel2))
  
# Normalize cell type proportion so that the proportion adds up to 1
temp1.cell2 <- rowSums(temp1.cel2[,-1]) %>% as.data.frame() %>% 'colnames<-' ("RowSum")
temp1.cell2$X <- temp1.cel2$X
for (k in 2:ncol(temp1.cel2)) {
    temp1.cell2[,k+1] <- temp1.cel2[,k] / temp1.cell2$RowSum
    colnames(temp1.cell2)[k+1] <- colnames(temp1.cel2)[k]
}
temp1.cel2 <- temp1.cell2[,-1]
  
# Aggregate cell2location results
temp1.cel2$immune_cel2 <- rowSums(temp1.cel2[which(str_detect(colnames(temp1.cel2), 
                                      "B.cells|T.cells|Macrophage|Plasmablasts|NK|Monocyte|Cycling_Myeloid|Cycling.T.cells|DCs"))])
temp1.cel2$stroma_cel2 <- rowSums(temp1.cel2[which(str_detect(colnames(temp1.cel2), 
                                      "CAFs|Endothelial|PVL|Cycling.PVL"))])
temp1.cel2$tumor_cel2 <- rowSums(temp1.cel2[which(str_detect(colnames(temp1.cel2), 
                                      "Cancer"))])
  
immune <- temp1.cel2$immune_cel2
names(immune) <- temp1.cel2$X

stroma <- temp1.cel2$stroma_cel2
names(stroma) <- temp1.cel2$X

tumor <- temp1.cel2$tumor_cel2
names(tumor) <- temp1.cel2$X

# Add deconvolution results to seurat object
bcsa <- AddMetaData(bcsa, immune, col.name = "immune_cel2")
bcsa <- AddMetaData(bcsa, stroma, col.name = "stroma_cel2")
bcsa <- AddMetaData(bcsa, tumor, col.name = "tumor_cel2")

# Plot deconvolution results
SpatialFeaturePlot(bcsa, features = "immune_cel2")
SpatialFeaturePlot(bcsa, features = "stroma_cel2")
SpatialFeaturePlot(bcsa, features = "tumor_cel2")

# Plot an HE image only
SpatialFeaturePlot(bcsa, features = "tumor_cel2", alpha = 0)

# Plot cell type markers
SpatialFeaturePlot(bcsa, features = c("PTPRC", "FAP", "EPCAM")) # immune, stroma, tumor marker

# Plot hormone receptors
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), ncol = 4, keep.scale = "all") 

```

## BCSA2TumB1

```{r BCSA2TumB1}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumB1.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA2TumB1_SCT.Rdata")

```

## BCSA2TumB2

```{r BCSA2TumB2}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumB2.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA2TumB2_SCT.Rdata")

```

## BCSA2TumC1

```{r BCSA2TumC1}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumC1.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA2TumC1_SCT.Rdata")

```

## BCSA2TumC2

```{r BCSA2TumC2}
load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumC2.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA2TumC2_SCT.Rdata")

```

## BCSA2TumD1

```{r BCSA2TumD1}
load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumD1.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA2TumD1_SCT.Rdata")
```

## BCSA2TumD2

```{r BCSA2TumD2}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumD2.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA2TumD2_SCT.Rdata")

```

## BCSA2TumD3

```{r BCSA2TumD3}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumD3.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA2TumD3_SCT.Rdata")

```

## BCSA2TumD4

```{r BCSA2TumD4}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumD4.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA2TumD4_SCT.Rdata")

```

## BCSA2TumE1

```{r BCSA2TumE1}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumE1.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA2TumE1_SCT.Rdata")

```

## BCSA2TumE2

```{r BCSA2TumE2}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumE2.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA2TumE2_SCT.Rdata")

```


## BCSA2 integration

```{r BCSA2 integration}

load("~/Desktop/CIIR/results/colocalization/BCSA2TumB1_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumB1", Cells(bcsa), sep = "_"))
bcsaTumb1 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA2TumB2_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumB2", Cells(bcsa), sep = "_"))
bcsaTumb2 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA2TumC1_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumC1", Cells(bcsa), sep = "_"))
bcsaTumc1 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA2TumC2_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumC2", Cells(bcsa), sep = "_"))
bcsaTumc2 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA2TumD1_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumD1", Cells(bcsa), sep = "_"))
bcsaTumd1 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA2TumD2_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumD2", Cells(bcsa), sep = "_"))
bcsaTumd2 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA2TumD3_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumD3", Cells(bcsa), sep = "_"))
bcsaTumd3 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA2TumD4_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumD4", Cells(bcsa), sep = "_"))
bcsaTumd4 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA2TumE1_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumE1", Cells(bcsa), sep = "_"))
bcsaTume1 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA2TumE2_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumE2", Cells(bcsa), sep = "_"))
bcsaTume2 <- bcsa

# Merge replicates first, merge does not support merging 4 samples at a time
bcsaTumb <- merge(bcsaTumb1, bcsaTumb2)
bcsaTumc <- merge(bcsaTumc1, bcsaTumc2)
bcsaTumda <- merge(bcsaTumd1, bcsaTumd2)
bcsaTumdb <- merge(bcsaTumd3, bcsaTumd4)
bcsaTume <- merge(bcsaTume1, bcsaTume2)

bcsa2 <- merge(bcsaTumb, bcsaTumc)
bcsa2 <- merge(bcsa2, bcsaTumda)
bcsa2 <- merge(bcsa2, bcsaTumdb)
bcsa2 <- merge(bcsa2, bcsaTume)

# split by original identity
ob_list <- SplitObject(bcsa2, split.by = "orig.ident")

ob_list <- lapply(ob_list, FUN = function(x) {
  x <- NormalizeData(x, normalization.method = "LogNormalize", scale.factor = 10000)
  x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 5000)
})

# select features that repeatedly variable across datasets for integration
features <- SelectIntegrationFeatures(object.list = ob_list) 

# For RPCA integration only
ob_list <- lapply(X = ob_list, FUN = function(x) {
    x <- ScaleData(x, features = features, verbose = FALSE)
    x <- RunPCA(x, features = features, verbose = FALSE)
})

library(future)
# Increase the maximum size of globals
options(future.globals.maxSize = 1024 * 1024 * 1024)  # 1 GiB

anchors <- FindIntegrationAnchors(object.list = ob_list, anchor.features = features, reduction = "rpca")
bcsa2 <- IntegrateData(anchorset = anchors)

bcsa2 <- bcsa2 %>% 
  #FindVariableFeatures() %>% 
  ScaleData(vars.to.regress = "percent_mito") %>% 
  RunNMF(nfactors = 20) 
bcsa2 <-FindNeighbors(bcsa2, dims = 1:20, reduction = "NMF")
bcsa2 <- FindClusters(bcsa2, resolution = 0.55, cluster.name = "integrated_clusters") %>% 
  RunUMAP(dims = 1:20, reduction = "NMF", reduction.name = "umap")
DimPlot(bcsa2, reduction = "umap", group.by = c("orig.ident", "seurat_clusters"))

col = c("0" = "#3C77AF",
        "1" = "#7DBFA7", "2" = "#EE934E", "4" = "#AECDE1",
        "3" = "#D1352B", "9" = "#F5CFE4", 
        "6" = "#FCED82", "7" = "#B383B9", "8" = "#BBDD78", 
        "5" = "grey", "9" = "#429948", "10" = "#7A2C2C")
SpatialDimPlot(bcsa2, ncol = 4, alpha = 1, cols = col) + plot_layout(guides = "collect")

DimPlot(bcsa2, reduction = "umap", group.by = "orig.ident")
DimPlot(bcsa2, reduction = "umap", group.by = "integrated_clusters", cols = col)

# Differential expression analysis to find markers
#cluster_markers <- FindAllMarkers(bcsa2, only.pos = T, test.use = "roc")
#markers <- cluster_markers %>% dplyr::group_by(cluster) %>% top_n(wt = power, 15)

# Differential expression analysis with wilcox to identify cluster 2 markers
cluster_markers_wilcox <- FindAllMarkers(bcsa2, only.pos = T, test.use = "wilcox") %>% 
  dplyr::group_by(cluster) %>% 
  top_n(wt = avg_log2FC, 50)

markers <- cluster_markers_wilcox %>% dplyr::group_by(cluster) %>% top_n(wt = avg_log2FC, 15)

# Plot the DEGs in each cluster
DoHeatmap(bcsa2, features = markers$gene, group.by = "ident",
          group.colors = col, slot = "scale.data", angle = 0, raster = F) 

# Percentage of each cluster in different tumor region
df <- table(bcsa2@meta.data$orig.ident, bcsa2@meta.data$integrated_clusters) %>% as.data.frame()
df <- df %>% group_by(Var1) %>% mutate(total = sum(Freq))
df$percent <- df$Freq / df$total
colnames(df)[2] <- "Clusters"

ggplot(df, aes(x = "", y = percent, fill = Clusters)) + geom_bar(stat = "identity") + 
  coord_polar("y", start = 0) + 
  theme_bw() + xlab("") + ylab("") +
  facet_wrap(~Var1) + scale_fill_manual(values = col)

# Rename Identity
bcsa2 <- RenameIdents(bcsa2, "0" = "Tumor", "1" = "Tumor", "2" = "Tumor-Immune",
                      "3" = "Stroma-Immune", "6" = "Low-density_area (Stroma)", "5" = "Immune", "7" = "Stroma",
                      "8" = "Stroma", "4" = "Stroma", "9" = "Tumor", "10" = "Stroma")
bcsa2 <- AddMetaData(bcsa2, bcsa2@active.ident, col.name = "Annotated_clusters")

col = c("Tumor" = "#429948", "Tumor-Immune" = "#BBDD78", "Stroma-Immune" = "#FCED82",
         "Immune" = "#FFDE18", "Stroma" = "#9BCCE3", "Low-density_area (Stroma)" = "#9BCCE3")
SpatialDimPlot(bcsa2, group.by = "Annotated_clusters", ncol = 4, cols = col, image.alpha = 0) +
  plot_layout(guides = "collect")

################## Identify RegionNeighbors using semla package
# Update seurat object to be used in semla package
bcsa2 <- UpdateSeuratForSemla(bcsa2)

# Identify tumor edge by using inner mode
bcsa2 <- RegionNeighbors(bcsa2, column_name = "Annotated_clusters", column_labels = "Tumor",
                              mode = "inner")

# Identify neighbors next to tumor cluster
bcsa2 <- RegionNeighbors(bcsa2, column_name = "Annotated_clusters", column_labels = "Tumor")

# Identify neighbors within and next to tumor cluster
bcsa2 <- RegionNeighbors(bcsa2, column_name = "Annotated_clusters", column_labels = "Tumor",
                              mode = "all_inner_outer", column_key = "all_nb_to")

#################### Check correlation between digital pathology and deconvolution on tumor edge
# Get the cell2location deconvolution results
decon <- data.frame()
for (i in names(bcsa2@images)) {
  temp1 <- read.csv(paste0("/Users/tili/Desktop/CIIR/results/cell2location/Merged_correlation_results/", 
                           i, "_correlation_matrix.csv"))[,c(1:12)]
  region <- gsub("BCSA2", "", i)
  temp1$X <- paste0(region, "_", temp1$X)
  decon <- rbind(decon, temp1)
}

# Filter out the tumor edge spots
edge <- bcsa2@meta.data %>% 
  dplyr::select(orig.ident, Annotated_clusters, inner_border_Tumor) %>% 
  na.omit() %>% 
  mutate(cellid = rownames(.))

# Filter out spots next to tumor cluster
outside <- bcsa2@meta.data %>% 
  dplyr::select(orig.ident, Annotated_clusters, nb_to_Tumor) %>% 
  na.omit() %>% 
  mutate(cellid = rownames(.))

# Filter out spots within and outside tumor cluster
all_spot <- bcsa2@meta.data %>% 
  dplyr::select(orig.ident, Annotated_clusters, all_nb_toTumor) %>% 
  na.omit() %>% 
  mutate(cellid = rownames(.))
inner <- all_spot[-which(all_spot$cellid %in% edge$cellid | all_spot$cellid %in% outside$cellid),]

decon_edge <- decon[which(decon$X %in% edge$cellid),]
decon_inner <- decon[-which(decon$X %in% inner$cellid),]

# Correlation on tumor edge
p1 <- ggplot(decon_edge, aes(x = tumor_cel2, y = tumor_per)) + geom_point() + theme_bw() +
    ggtitle(paste0("Cell2location: Tumor edge correlation")) + geom_smooth(method = "lm") + 
  ggpubr::stat_cor(method = "spearman")

p2 <- ggplot(decon_inner, aes(x = tumor_cel2, y = tumor_per)) + geom_point() + theme_bw() +
    ggtitle(paste0("Cell2location: Tumor inner part correlation")) + geom_smooth(method = "lm") + 
  ggpubr::stat_cor(method = "spearman")

p1 + p2

################# Percentage of each cluster on the tumor edge

e2_edge_id <- decon_edge[which(str_detect(decon_edge$X, "TumE2")),]$X
e2 <- read.csv("~/Desktop/CIIR/results/cell2location/Merged_correlation_results/BCSA2TumE2_correlation_matrix.csv") %>% 
  dplyr::select(X, immune_cel2, stroma_cel2, tumor_cel2, col_30p, row_30p_reverse) 
e2$col <- e2$col_30p * 0.1370614
e2$row_reverse <- e2$row_30p_reverse * 0.1370614
e2$X <- paste0("TumE2_", e2$X)
e2 <- e2[which(e2$X %in% e2_edge_id),]

# Add HE image on the back
ima <- magick::image_read("/Users/tili/Desktop/CIIR/data/visium_spatial_out/V10F24-114_D1/tissue_hires_image.png")
image_in <- magick::image_info(ima)
width <- image_in$width
height <- image_in$height

# Plot the visium spots
p <- ggplot(e2, aes(y = row_reverse, x =col)) + 
  annotation_raster(ima, ymin = 0, ymax= height, xmin = 0, xmax = width) +
  geom_point() + theme_bw()

col = c("tumor_cel2" = "#429948", 
          "immune_cel2" = "#FFDE18", "stroma_cel2" = "#9BCCE3")

# Function to create pie charts as grobs
create_pie_grob <- function(pie_data) {
  pie <- ggplot(pie_data, aes(x = "", y = percent, fill = clusters)) +
    geom_bar(stat = "identity", width = 1) +
    coord_polar("y") +
    theme_void() + scale_fill_manual(values = col) +
    theme(legend.position = "none")  # Remove legend for simplicity
  grob <- ggplotGrob(pie)
  return(grob)
}

# Add pie charts to the scatter plot
for (i in 1:nrow(e2)) {
  temp1 <- e2[i, 1:4] %>% as.data.frame() %>% 
    pivot_longer(!X, names_to = "clusters", values_to = "percent")
  # Remove the spotid column for correct plotting
  temp1 <- temp1[,-1]
  pie_grob <- create_pie_grob(temp1)
  p <- p + annotation_custom(pie_grob, xmin = e2$col[i] - 8, xmax = e2$col[i] + 8,
                             ymin = e2$row_reverse[i] - 8, ymax = e2$row_reverse[i] + 8)
}
print(p)

################## Check what cluster is next to each tumor cluster

# Identify neighbors next to tumor cluster
bcsa2 <- RegionNeighbors(bcsa2, column_name = "integrated_clusters", column_labels = "0", 
                         column_key = "nb_to_tumor_")
bcsa2 <- RegionNeighbors(bcsa2, column_name = "integrated_clusters", column_labels = "1", 
                         column_key = "nb_to_tumor_")
bcsa2 <- RegionNeighbors(bcsa2, column_name = "integrated_clusters", column_labels = "9", 
                         column_key = "nb_to_tumor_")

temp1 <- data.frame()
for (i in names(bcsa2@images)) {
  temp1.cel2 <- read.csv(paste0("/Users/tili/Desktop/CIIR/results/cell2location/", 
                           i, "_q05.csv"))
  colnames(temp1.cel2) <- gsub("q05cell_abundance_w_sf_", "", colnames(temp1.cel2))
  
  # Normalize cell type proportion so that the proportion adds up to 1
  temp1.cell2 <- rowSums(temp1.cel2[,-1]) %>% as.data.frame() %>% 'colnames<-' ("RowSum")
  temp1.cell2$X <- temp1.cel2$X
  for (k in 2:ncol(temp1.cel2)) {
    temp1.cell2[,k+1] <- temp1.cel2[,k] / temp1.cell2$RowSum
    colnames(temp1.cell2)[k+1] <- colnames(temp1.cel2)[k]
  }
  temp1.cel2 <- temp1.cell2[,-1]
  
  sec_id <- gsub("BCSA2", "", i)
  rownames(temp1.cel2) <- paste0(sec_id, "_", temp1.cel2$X)
  temp1.cel2 <- temp1.cel2[,-1]
  
  temp1 <- rbind(temp1, temp1.cel2)
}

nb <- bcsa2@meta.data %>% dplyr::select(nb_to_tumor_0, nb_to_tumor_1, nb_to_tumor_9)
nb$spotid <- rownames(nb)

# Filter out tumor 0 neighbors
t0_nb <- nb[,c(1,4)] %>% na.omit()
t0 <- temp1[which(rownames(temp1) %in% t0_nb$spotid),]

# Plot colocalization/interactions
SPOTlight::plotInteractions(as.matrix(t0), which = "network")

# Filter out tumor 1 neighbor
t1_nb <- nb[,c(2,4)] %>% na.omit()
t1 <- temp1[which(rownames(temp1) %in% t1_nb$spotid),]

SPOTlight::plotInteractions(as.matrix(t1), which = "network")

# Filter out tumor 9 neighbor
t9_nb <- nb[,c(3,4)] %>% na.omit()
t9 <- temp1[which(rownames(temp1) %in% t9_nb$spotid),]

SPOTlight::plotInteractions(as.matrix(t9), which = "network")

# Filter out tumor border
nb <- bcsa2@meta.data %>% dplyr::select(inner_border_Tumor, nb_to_Tumor)
nb$spotid <- rownames(nb)
tumor_nb <- nb[,c(2,3)] %>% na.omit()
tumor <- temp1[which(rownames(temp1) %in% tumor_nb$spotid),]

SPOTlight::plotInteractions(as.matrix(tumor), which = "network")

# Plot colocalization/interactions in the whole section
SPOTlight::plotInteractions(as.matrix(temp1), which = "network")

################## GSVA on the sub-clusters
Idents(bcsa2) <- bcsa2@meta.data$integrated_clusters

# Aggregate expression in each cluster
pseudo_bcsa2 <- AggregateExpression(bcsa2, assays = "Spatial", return.seurat = T, group.by = "integrated_clusters")

# Extract data matrix from the counts slot
pseudo_matrix <- GetAssayData(pseudo_bcsa2, assay = "Spatial", layer = "counts") %>% as.data.frame()

# Normalization
normalized_pseudo <- edgeR::cpm(pseudo_matrix, normalized.lib.sizes = T, log = T)

# Hallmark gene set
geneset <- getGmt("/Users/tili/Desktop/CIIR/data/h.all.v2024.1.Hs.symbols.gmt")

# GSVA analysis
# kcdf value "Gaussian" is suitable for continuous expression data, such as microarray fluorescent units in logarithmic scale and 
# RNA-seq log-CPMs, log-RPKMs or log-TPMs units of expression; "Poisson" is suitable for integer counts, such as those 
# derived from RNA-seq alignments
gsvaPar <- gsvaParam(as.matrix(normalized_pseudo), geneset, kcdf = "Gaussian")
gsva.es <- gsva(gsvaPar, verbose=FALSE)

Heatmap(gsva.es,
        cluster_columns = T,
        cluster_rows = T,
        show_row_names = T,
        show_column_names = T,
        clustering_distance_rows = "euclidean",
        color = colorRampPalette(c("blue", "white", "red"))(100))

######################### DE analysis on different tumor clusters

Idents(bcsa2) <- bcsa2@meta.data$integrated_clusters
t0_vs_t1 <- FindMarkers(bcsa2, ident.1 = "0", ident.2 = "1")
t0_vs_t1$gene <- rownames(t0_vs_t1)

# Get entrez id
entrez <- clusterProfiler::bitr(rownames(t0_vs_t1), fromType = "SYMBOL", 
                                         toType = "ENTREZID", OrgDb = org.Hs.eg.db)
t0_vs_t1 <- merge(t0_vs_t1, entrez, by.x = "gene", by.y = "SYMBOL", all.x = F)

# Create a genelist for gseGO analysis
genelist <- t0_vs_t1$avg_log2FC
names(genelist) <- t0_vs_t1$ENTREZID
genelist <- sort(genelist, decreasing = T)

# gseGO analysis
go <- gseGO(genelist, ont = "BP", OrgDb = org.Hs.eg.db, 
            keyType = "ENTREZID", minGSSize = 10, maxGSSize = 500,
            pvalueCutoff = 0.05, pAdjustMethod = "BH")
go <- setReadable(go, OrgDb = org.Hs.eg.db,keyType = "ENTREZID")

# Plot gseGO results, cluster the top30 GOs
go2 <- pairwise_termsim(go)
treeplot(go2, showCategory = 30, color = "NES") + ggtitle("BCSA2 Tumor 0 vs 1") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4, 4))
openxlsx::write.xlsx(go2@result, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA2_tumor_cluster_0_vs_1_gseGO_20241015.xlsx")

### t0 vs t9 cluster
t0_vs_t9 <- FindMarkers(bcsa2, ident.1 = "0", ident.2 = "9")
t0_vs_t9$gene <- rownames(t0_vs_t9)

# Get entrez id
entrez <- clusterProfiler::bitr(rownames(t0_vs_t9), fromType = "SYMBOL", 
                                         toType = "ENTREZID", OrgDb = org.Hs.eg.db)
t0_vs_t9 <- merge(t0_vs_t9, entrez, by.x = "gene", by.y = "SYMBOL", all.x = F)

# Create a genelist for gseGO analysis
genelist <- t0_vs_t9$avg_log2FC
names(genelist) <- t0_vs_t9$ENTREZID
genelist <- sort(genelist, decreasing = T)

# gseGO analysis
go <- gseGO(genelist, ont = "BP", OrgDb = org.Hs.eg.db, 
            keyType = "ENTREZID", minGSSize = 10, maxGSSize = 500,
            pvalueCutoff = 0.05, pAdjustMethod = "BH")
go <- setReadable(go, OrgDb = org.Hs.eg.db,keyType = "ENTREZID")

# Plot gseGO results, cluster the top30 GOs
go2 <- pairwise_termsim(go)
treeplot(go2, showCategory = 30, color = "NES") + ggtitle("BCSA2 Tumor 0 vs 9") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4, 4))
openxlsx::write.xlsx(go2@result, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA2_tumor_cluster_0_vs_9_gseGO_20241015.xlsx")

### t1 vs t9 cluster
t1_vs_t9 <- FindMarkers(bcsa2, ident.1 = "1", ident.2 = "9")
t1_vs_t9$gene <- rownames(t1_vs_t9)

# Get entrez id
entrez <- clusterProfiler::bitr(rownames(t1_vs_t9), fromType = "SYMBOL", 
                                         toType = "ENTREZID", OrgDb = org.Hs.eg.db)
t1_vs_t9 <- merge(t1_vs_t9, entrez, by.x = "gene", by.y = "SYMBOL", all.x = F)

# Create a genelist for gseGO analysis
genelist <- t1_vs_t9$avg_log2FC
names(genelist) <- t1_vs_t9$ENTREZID
genelist <- sort(genelist, decreasing = T)

# gseGO analysis
go <- gseGO(genelist, ont = "BP", OrgDb = org.Hs.eg.db, 
            keyType = "ENTREZID", minGSSize = 10, maxGSSize = 500,
            pvalueCutoff = 0.05, pAdjustMethod = "BH")
go <- setReadable(go, OrgDb = org.Hs.eg.db,keyType = "ENTREZID")

# Plot gseGO results, cluster the top30 GOs
go2 <- pairwise_termsim(go)
treeplot(go2, showCategory = 30, color = "NES") + ggtitle("BCSA2 Tumor 1 vs 9") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4, 4))
openxlsx::write.xlsx(go2@result, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA2_tumor_cluster_1_vs_9_gseGO_20241015.xlsx")

save(bcsa2, cluster_markers_wilcox, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA2_merge.Rdata")

########################### UMAP colored by QuPath annotation ###############

umap_em <- bcsa2@reductions$umap@cell.embeddings %>% as.data.frame()
umap_em$spotid <- rownames(umap_em)

# Merge UMAP coordinates with QuPath classification results
umap_em <- merge(umap_em, decon, by.x = "spotid", by.y = "X", all.x = F, all.y = T)

# Plot UMAP
tumor_color <- "#D2817E"  # Custom reddish color
immune_color <- "#FFDE18" # Custom yellowish color
stroma_color <- "#9BCCE3" # Custom bluish color

# Create a color ramp function for each custom color
tumor_ramp <- colorRamp(c("black", tumor_color))
immune_ramp <- colorRamp(c("black", immune_color))
stroma_ramp <- colorRamp(c("black", stroma_color))

# Blend custom colors based on the proportions
umap_em$custom_color <- apply(
  umap_em[, c("tumor_per", "immune_per", "stroma_per")], 1, function(row) {
    # Weighted blending of tumor, immune, and stroma colors
    blended <- tumor_ramp(row["tumor_per"]) +
               immune_ramp(row["immune_per"]) +
               stroma_ramp(row["stroma_per"])
    blended <- blended / max(blended) * 255  # Normalize to keep within 0–255 range
    rgb(blended[1] / 255, blended[2] / 255, blended[3] / 255) # Convert to hex
  }
)

# Plot the UMAP with the custom blended colors
ggplot(umap_em, aes(x = umap_1, y = umap_2, col = custom_color)) +
  geom_point(size = 0.3) + 
  scale_colour_identity() +
  new_scale_color() +
  geom_point(aes(col = tumor_per), shape = NA) +
  scale_color_gradient(low = "black", high = "#D2817E") +
  new_scale_color() +
  geom_point(aes(col = immune_per), shape = NA) +
  scale_color_gradient(low = "black", high = "#FFDE18") +
  new_scale_color() +
  geom_point(aes(col = stroma_per), shape = NA) +
  scale_color_gradient(low = "black", high = "#9BCCE3") +
  new_scale_color() + theme_bw() +
  xlab("UMAP1") + ylab("UMAP2")

```

## BCSA2 QuPath cell percentage in different tumor clusters

```{r BCSA2 QuPath cell percent in tumor clusters}

qupath <- read.csv("/Users/tili/Desktop/CIIR/results/Cell_annotation_qupath_analyzed/cell_qupath_combined_20241014.csv")
qupath$spot <- paste0(str_sub(qupath$id, start = 6), "_", qupath$cellid)
qupath$patient <- str_sub(qupath$id, end = 5)

# Extract tumor spot id
df <- bcsa2@meta.data %>% dplyr::select(orig.ident, integrated_clusters)

# Filter out spot id for tumor clusters
#spotid <- df[which(df$integrated_clusters == 1 | df$integrated_clusters == 0 | 
#                        df$integrated_clusters == 9),]

# Take spot id from all clusters
spotid <- df
spotid$spot <- rownames(spotid)

bcsa2_tumor <- qupath[which(qupath$spot %in% spotid$spot & qupath$patient == "BCSA2"),]
bcsa2_tumor <- merge(bcsa2_tumor, spotid, by.x = "spot", by.y = "spot")

# Calculate the percent of tumor, immune, and stroma in each cluster
bcsa2_freq <- bcsa2_tumor %>% dplyr::group_by(integrated_clusters) %>% 
  dplyr::count(Classification) %>% 
  dplyr::filter(Classification != "")

bcsa2_freq <- bcsa2_freq %>% dplyr::group_by(integrated_clusters) %>% mutate(Total = sum(n))
bcsa2_freq$Percent <- bcsa2_freq$n / bcsa2_freq$Total
bcsa2_freq$Cluster <- paste0("Cluster", bcsa2_freq$integrated_clusters)

bcsa2_freq$Cluster <- factor(bcsa2_freq$Cluster, levels = c("Cluster0", "Cluster1", "Cluster2",
                                                            "Cluster3", "Cluster4", "Cluster5",
                                                            "Cluster6", "Cluster7", "Cluster8",
                                                            "Cluster9", "Cluster10"))

bcsa2_freq$spot_n <- rep(table(bcsa2@meta.data$integrated_clusters), each = 3)
bcsa2_freq$spot_density <- round(bcsa2_freq$Total / bcsa2_freq$spot_n, 2)

# Plot the cell type percent in each tumor cluster
ggplot(bcsa2_freq, aes(x = Cluster, y = Percent, fill = Classification)) + 
  geom_bar(stat = "identity", position = "stack") + theme_bw() +
  scale_fill_manual(values = c("Tumor" = "#429948", 
          "Immune cells" = "#FFDE18", "Stroma" = "#9BCCE3")) + xlab("") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

## BCSA2 Metabolic score estimation with METAFlux

```{r METAFlux estimation}

# Perform metabolic score estimation on pseudobulk aggregate samples
# The gene expression matrix should be gene x sample matrix where row names are human gene names (gene symbols), and column names should be sample names. Please note that METAFlux does not support other gene IDs.
# The input gene expression matrix should be normalized (e.g., log-transformed, etc.) before using METAFlux. METAflux will not perform any normalization on expression data.
# Gene expression data cannot have negative values.
normalized_pseudo <- edgeR::cpm(pseudo_matrix, normalized.lib.sizes = T, log = F)
log_pseudo <- log2(normalized_pseudo + 1)

# We used Human-GEM (consisting of 13082 metabolic reactions and 8378 metabolites) as our underlying metabolic model
data("human_gem")

# In METAFlux, ‘medium’ reflects the nutrients (metabolites) in the sample tumor microenvironment (TME) and those nutrients can be allowed to uptake into cells.
data("human_blood")# for human derived samples

# Calculate a single sample normalized MRAS (Metabolic Reaction Activity Score) from gene expression using GPR (Gene-protein-reaction).
scores <- calculate_reaction_score(log_pseudo)

# Calculate the metabolic fluxes for the 13082 reactions
flux <- compute_flux(mras=scores, medium = human_blood)

# Apply cubic root normalization to flux scores.
cbrt <- function(x) {
    sign(x) * abs(x)^(1/3)
}

flux <- cbrt(flux)

# Search “nutrient lookup file” to obtain the metabolite exchange Reaction ID
data("nutrient_lookup_files")

# “Sign” of flux indicates the direction. For example, for the nutrient uptake/release case (1648 exchange reactions in nutrient lookup file), a positive value means a release of compounds, and a negative value means uptake of compounds.
glucose <- flux[human_gem[str_detect(human_gem$SUBSYSTEM, "Glycolysis"),]$ID,]
ComplexHeatmap::Heatmap(glucose, cluster_rows = T,
                        cluster_columns = T,
                        show_row_names = T,
                        show_column_names = T,
                        clustering_distance_rows = "euclidean",
                        color = colorRampPalette(c("blue", "white", "red"))(100))

cholesterol <- flux[human_gem[str_detect(human_gem$SUBSYSTEM, "Cholesterol"),]$ID,]
ComplexHeatmap::Heatmap(cholesterol, cluster_rows = T,
                        cluster_columns = T,
                        show_row_names = T,
                        show_column_names = T,
                        clustering_distance_rows = "euclidean",
                        color = colorRampPalette(c("blue", "white", "red"))(100))

```

## BCSA2 inferCNV

```{r BCSA2 inferCNV}

cnv <- readRDS("/Users/tili/Desktop/CIIR/results/infercnv/BCSA2_i3/run.final.scaled.infercnv_obj")

# infercnv_obj@expr.data is the scaled cnv number for each dot in column and gene in row;
# infercnv_obj@gene_order is the gene location, chr, start and end.

bcsa2_cnv_matrix <- cnv@expr.data
gene_order <- cnv@gene_order
gene_order$gene <- rownames(gene_order)

meta <- bcsa2@meta.data %>% dplyr::select(integrated_clusters, orig.ident)
meta$spotid <- rownames(meta)
meta <- meta[which(meta$spotid %in% colnames(bcsa2_cnv_matrix)),]

col = c("0" = "#3C77AF",
        "1" = "#7DBFA7", "2" = "#EE934E", "4" = "#AECDE1",
        "3" = "#D1352B", "9" = "#F5CFE4", 
        "6" = "#FCED82", "7" = "#B383B9", "8" = "#BBDD78", 
        "5" = "grey", "9" = "#429948", "10" = "#7A2C2C")
ha <- HeatmapAnnotation(Cluster = meta$integrated_clusters, col = list(Cluster = col))

col_fun <- colorRamp2(
  breaks = c(0.8, 1, 1.2),  # Values to map
  colors = c("blue", "white", "red")  # Colors corresponding to the values
)

# Cluster by column (integrated clusters)
Heatmap(bcsa2_cnv_matrix, cluster_rows = F, 
        show_row_names = F, show_column_names = F,
        row_split = gene_order$chr, 
        top_annotation = ha, col = col_fun, 
        column_split = meta$integrated_clusters, cluster_column_slices = T)

# Save results
write.csv(bcsa2_cnv_matrix, file = "/Users/tili/Desktop/CIIR/results/infercnv/BCSA2_i3/bcsa2_cnv_matrix.csv")
write.csv(gene_order, file = "/Users/tili/Desktop/CIIR/results/infercnv/BCSA2_i3/gene_order.csv")

# Extract meta data
normal <- read.delim("/Users/tili/Desktop/CIIR/results/infercnv/BCSA2_ref_spot.txt", header = F)
normal$type <- rep("Normal", nrow(normal))
tumor <- read.delim("/Users/tili/Desktop/CIIR/results/infercnv/BCSA2_filtered_tumor_40_percent_spots_rep1_for_inferCNV.txt", header = F)
tumor$type <- rep("Tumor", nrow(tumor))
spots <- rbind(normal, tumor)
spots <- spots[which(spots$V1 %in% colnames(bcsa2_cnv_matrix)),]

tumor_matrix <- bcsa2_cnv_matrix[, which(colnames(bcsa2_cnv_matrix) %in% tumor$V1)]

# Cluster by clone
hm <- Heatmap(as.matrix(tumor_matrix), cluster_rows = F, 
              show_row_names = F, show_column_names = F, cluster_columns = T,
              col = col_fun, 
              border = F,
              clustering_method_columns = "ward.D",
              row_split = gene_order$chr
)

# Extract dendrogram for each cluster
col_order_list <- column_dend(hm)

# Cut tree at height 150 to get 3 clusters
dend1 <- col_order_list[[1]]
temp1 <- cutree(dend1, h = 1380) %>% as.data.frame()
temp1$cluster <- ifelse(str_detect(temp1$., "1"), "A", "B")
clone1 <- temp1$cluster
names(clone1) <- rownames(temp1)

dend2 <- col_order_list[[2]]
temp1 <- cutree(dend2, h = 1380) %>% as.data.frame()
temp1$cluster <- dplyr::recode(temp1$., `1` = "B", `2` = "C")#
                               #, `3` = "E", `4` = "F", `5` = "G", `6` = "H")
clone2 <- temp1$cluster
names(clone2) <- rownames(temp1)

clone <- c(clone1, clone2)

# Add results to bcsa meta data
bcsa <- subset(bcsa2, orig.ident %in% c("BCSA2TumB1", "BCSA2TumC1", "BCSA2TumD1", "BCSA2TumE1"))
bcsa <- subset(bcsa, cells = names(clone))
bcsa <- AddMetaData(bcsa, clone, col.name = "inferCNV")
co <- c("A" = "#35A153", "B" = "#FFCD44", "C" = "#1d9bf7", "D" = "#d95f0e", 
        "E" = "#c51b7d", "F" = "#bf812d", "G" = "#35978f", "H" = "#878787")
SpatialDimPlot(bcsa, group.by = "inferCNV", cols = co, ncol = 2)

# Plot heatmap with clone information
clones <- as.data.frame(clone)
clones$spotid <- rownames(clones)
clones <- merge(clones, meta, by.x = "spotid", by.y = "spotid", all.x = T, all.y = F)

# Sankey plot
df2 <- clones %>% make_long(integrated_clusters, clone)
col = c("0" = "#3C77AF",
        "1" = "#7DBFA7", "2" = "#EE934E", "4" = "#AECDE1",
        "3" = "#D1352B", "9" = "#F5CFE4", 
        "6" = "#FCED82", "7" = "#B383B9", "8" = "#BBDD78", 
        "5" = "grey", "9" = "#429948", "10" = "#7A2C2C",
        "A" = "#35A153", "B" = "#FFCD44", "C" = "#1d9bf7", "D" = "#d95f0e",
        "E" = "#c51b7d", "F" = "#bf812d", "G" = "#35978f", "H" = "#878787")
ggplot(df2, aes(x = x, 
                next_x = next_x, 
                node = node, 
                next_node = next_node,
                fill = factor(node))) +
  geom_sankey(flow.alpha = .6,
              node.color = "gray30") +
  geom_sankey_label(aes(label = node), size = 3, color = "white") +
  scale_fill_manual(values = col, drop = FALSE) +
  theme_sankey(base_size = 18) +
  labs(x = NULL) +
  theme(legend.position = "none",
        plot.title = element_text(hjust = .5))

ha <- HeatmapAnnotation(Cluster = clones$integrated_clusters, col = list(Cluster = col))
ba <- rowAnnotation(Clone = clones$clone, col = list(Clone = co))

col_ha <- HeatmapAnnotation(foo = anno_mark(at = which(colnames(t(tumor_matrix)) %in% c("ERBB2")),
                                            labels = c("ERBB2")))

pdf(file = "/Users/tili/Desktop/CIIR/results/inferCNV/BCSA2_inferCNV_heatmap_3_clones.pdf", width = 18, height = 9)
Heatmap(t(as.matrix(tumor_matrix)), cluster_rows = T, 
        show_row_names = F, show_column_names = F, cluster_columns = F,
        col = col_fun, 
        row_split = clones$clone,
        left_annotation = ba,
        bottom_annotation = col_ha,
        clustering_method_rows = "ward.D",
        column_split = gene_order$chr
)
dev.off()
```

## BCSA2 PAM50

```{r BCSA2 PAM50}

# load PAM50 results
load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumB1_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumB1", Cells(bcsa), sep = "_"))
bcsaTumb1 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumB2_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumB2", Cells(bcsa), sep = "_"))
bcsaTumb2 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumC1_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumC1", Cells(bcsa), sep = "_"))
bcsaTumc1 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumC2_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumC2", Cells(bcsa), sep = "_"))
bcsaTumc2 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumD1_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumD1", Cells(bcsa), sep = "_"))
bcsaTumd1 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumD2_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumD2", Cells(bcsa), sep = "_"))
bcsaTumd2 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumD3_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumD3", Cells(bcsa), sep = "_"))
bcsaTumd3 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumD4_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumD4", Cells(bcsa), sep = "_"))
bcsaTumd4 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumE1_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumE1", Cells(bcsa), sep = "_"))
bcsaTume1 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumE2_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumE2", Cells(bcsa), sep = "_"))
bcsaTume2 <- bcsa

# Merge replicates first, merge does not support merging 4 samples at a time
bcsaTumc <- merge(bcsaTumc1, bcsaTumc2)
bcsaTumb <- merge(bcsaTumb1, bcsaTumb2)
bcsaTumd <- merge(bcsaTumd1, bcsaTumd2)
bcsaTumd2 <- merge(bcsaTumd3, bcsaTumd4)
bcsaTume <- merge(bcsaTume1, bcsaTume2)

bcsa2_pam50 <- merge(bcsaTumb, bcsaTumc)
bcsa2_pam50 <- merge(bcsa2_pam50, bcsaTumd)
bcsa2_pam50 <- merge(bcsa2_pam50, bcsaTumd2)
bcsa2_pam50 <- merge(bcsa2_pam50, bcsaTume)

# Aggregate deconvolution results
temp1 <- data.frame()
for (i in names(bcsa2@images)) {
  temp1.cel2 <- read.csv(paste0("/Users/tili/Desktop/CIIR/results/cell2location/", i, "_q05.csv"))
  colnames(temp1.cel2) <- gsub("q05cell_abundance_w_sf_", "", colnames(temp1.cel2))
  
  # Normalize cell type proportion so that the proportion adds up to 1
  temp1.cell2 <- rowSums(temp1.cel2[,-1]) %>% as.data.frame() %>% 'colnames<-' ("RowSum")
  temp1.cell2$X <- temp1.cel2$X
  for (k in 2:ncol(temp1.cel2)) {
    temp1.cell2[,k+1] <- temp1.cel2[,k] / temp1.cell2$RowSum
    colnames(temp1.cell2)[k+1] <- colnames(temp1.cel2)[k]
  }
  temp1.cel2 <- temp1.cell2[,-1]
  region <- gsub("BCSA2", "", i)
  temp1.cel2$X <- paste0(region, "_", temp1.cel2$X)
  temp1 <- rbind(temp1, temp1.cel2)
}

# Aggregate epithelial clusters
temp1$epithelial <- rowSums(temp1[which(str_detect(colnames(temp1), 
                                      "Cancer|Mature.Luminal|Luminal.Progenitors|Myoepithelial"))])

# Filter out spots does not have 20% of epithelial
temp1_filtered <- temp1[which(temp1$epithelial > 0.2), ]

pam50 <- bcsa2_pam50@meta.data$subtypecd_aims
names(pam50) <- rownames(bcsa2_pam50@meta.data)

# Keep spots that are only used in the clustering and with at least 20% of epithelial cells
pam50 <- pam50[which(names(pam50) %in% temp1_filtered$X)]
pam50 <- pam50[which(names(pam50) %in% colnames(bcsa2))]

bcsa2_pam50 <- bcsa2
bcsa2_pam50 <- AddMetaData(bcsa2_pam50, pam50, col.name = "PAM50_aims")

# Subset the seurat object
temp1_filtered <- temp1_filtered[which(temp1_filtered$X %in% colnames(bcsa2)),]
bcsa2_pam50 <- subset(bcsa2_pam50, cells = temp1_filtered$X)

# Filter out spots without tumor based on QuPath annotation
ref <- read.delim("/Users/tili/Desktop/CIIR/results/infercnv/BCSA2_ref_spot.txt", header = F)
temp1_tumor <- temp1_filtered[-which(temp1_filtered$X %in% ref$V1),]

# Subset the seurat object
bcsa2_pam50 <- subset(bcsa2_pam50, cells = temp1_tumor$X)

col <- c("NBL" = "#66c530", "H2" = "#d4279c", "LA" = "#2a3188", "LB" = "#419ad2", "BL" = "#97191e")
SpatialDimPlot(bcsa2_pam50, group.by = "PAM50_aims", ncol = 4, cols = col) + 
  plot_layout(guides = "collect")

# Pie chart for PAM50 percent
df <- table(bcsa2_pam50@meta.data$PAM50_aims) %>% as.data.frame()
df$Total <- sum(df$Freq)
df$Percent <- df$Freq / df$Total

pie(df$Freq, labels = paste(df$Var1, round(df$Percent * 100, 2), "%"), 
    col = c("H2" = "#d4279c", "LA" = "#2a3188", "NBL" = "#66c530"), main = "BCSA2 PAM50")

############## Calculate the percentage of each cluster in each intrinsic subtype
meta <- bcsa2_pam50@meta.data %>% as.data.frame() 
cluster_freq <- meta %>% dplyr::group_by(PAM50_aims) %>% 
  dplyr::count(integrated_clusters)

cluster_freq <- cluster_freq %>% dplyr::group_by(PAM50_aims) %>% mutate(Total = sum(n))
cluster_freq$Percent <- cluster_freq$n / cluster_freq$Total

ggplot(cluster_freq, aes(x = PAM50_aims, y = Percent, fill = integrated_clusters)) + 
  geom_bar(stat = "identity", position = "stack") + theme_bw() +
  scale_fill_manual(values = c("0" = "#3C77AF",
        "1" = "#7DBFA7", "2" = "#EE934E", "4" = "#AECDE1",
        "3" = "#D1352B", "9" = "#F5CFE4", 
        "6" = "#FCED82", "7" = "#B383B9", "8" = "#BBDD78", 
        "5" = "grey", "9" = "#429948", "10" = "#7A2C2C")) + xlab("") 

########## Plot the cell type percent from QuPath
qupath <- read.csv("/Users/tili/Desktop/CIIR/results/Cell_annotation_qupath_analyzed/cell_qupath_combined_20241014.csv")
qupath$spot <- paste0(str_sub(qupath$id, start = 6), "_", qupath$cellid)
qupath$patient <- str_sub(qupath$id, end = 5)

# Extract tumor spot id
spotid <- bcsa2_pam50@meta.data %>% as.data.frame()
spotid$X <- rownames(spotid)

bcsa2_filtered <- qupath[which(qupath$spot %in% spotid$X & qupath$patient == "BCSA2"),]
bcsa2_filtered <- merge(bcsa2_filtered, spotid, by.x = "spot", by.y = "X")

# Calculate the percent of tumor, immune, and stroma in intrinsic subtype
bcsa2_freq <- bcsa2_filtered %>% dplyr::group_by(PAM50_aims) %>% 
  dplyr::count(Classification) %>% 
  dplyr::filter(Classification != "")

bcsa2_freq <- bcsa2_freq %>% dplyr::group_by(PAM50_aims) %>% mutate(Total = sum(n))
bcsa2_freq$Percent <- bcsa2_freq$n / bcsa2_freq$Total

# Plot the cell type percent in each tumor cluster
ggplot(bcsa2_freq, aes(x = PAM50_aims, y = Percent, fill = Classification)) + 
  geom_bar(stat = "identity", position = "stack") + theme_bw() +
  scale_fill_manual(values = c("Tumor" = "#429948", 
          "Immune cells" = "#FFDE18", "Stroma" = "#9BCCE3")) + xlab("") 

```

## BCSA2 TumE2 cell type markers and deconvolution

```{r BCSA2TumE2 cell type markers and deconvolution}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA2TumE2_processed.RData")

temp1.cel2 <- read.csv("/Users/tili/Desktop/CIIR/results/cell2location/BCSA2TumE2_q05.csv")
colnames(temp1.cel2) <- gsub("q05cell_abundance_w_sf_", "", colnames(temp1.cel2))
  
# Normalize cell type proportion so that the proportion adds up to 1
temp1.cell2 <- rowSums(temp1.cel2[,-1]) %>% as.data.frame() %>% 'colnames<-' ("RowSum")
temp1.cell2$X <- temp1.cel2$X
for (k in 2:ncol(temp1.cel2)) {
    temp1.cell2[,k+1] <- temp1.cel2[,k] / temp1.cell2$RowSum
    colnames(temp1.cell2)[k+1] <- colnames(temp1.cel2)[k]
}
temp1.cel2 <- temp1.cell2[,-1]
  
# Aggregate cell2location results
temp1.cel2$immune_cel2 <- rowSums(temp1.cel2[which(str_detect(colnames(temp1.cel2), 
                                      "B.cells|T.cells|Macrophage|Plasmablasts|NK|Monocyte|Cycling_Myeloid|Cycling.T.cells|DCs"))])
temp1.cel2$stroma_cel2 <- rowSums(temp1.cel2[which(str_detect(colnames(temp1.cel2), 
                                      "CAFs|Endothelial|PVL|Cycling.PVL"))])
temp1.cel2$tumor_cel2 <- rowSums(temp1.cel2[which(str_detect(colnames(temp1.cel2), 
                                      "Cancer"))])
  
immune <- temp1.cel2$immune_cel2
names(immune) <- temp1.cel2$X

stroma <- temp1.cel2$stroma_cel2
names(stroma) <- temp1.cel2$X

tumor <- temp1.cel2$tumor_cel2
names(tumor) <- temp1.cel2$X

# Add deconvolution results to seurat object
bcsa <- AddMetaData(bcsa, immune, col.name = "immune_cel2")
bcsa <- AddMetaData(bcsa, stroma, col.name = "stroma_cel2")
bcsa <- AddMetaData(bcsa, tumor, col.name = "tumor_cel2")

bcsa$immune_cel2[which(is.na(bcsa$immune_cel2))] <- 0
bcsa$stroma_cel2[which(is.na(bcsa$stroma_cel2))] <- 0
bcsa$tumor_cel2[which(is.na(bcsa$tumor_cel2))] <- 0

# Plot deconvolution results
SpatialFeaturePlot(bcsa, features = "immune_cel2")
SpatialFeaturePlot(bcsa, features = "stroma_cel2")
SpatialFeaturePlot(bcsa, features = "tumor_cel2")

# Plot an HE image only
SpatialFeaturePlot(bcsa, features = "tumor_cel2", alpha = 0)

# Plot cell type markers
SpatialFeaturePlot(bcsa, features = c("PTPRC", "FAP", "EPCAM")) # immune, stroma, tumor marker

# Plot hormone receptors
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), ncol = 4, keep.scale = "all")

```

## BCSA3TumA1

```{r BCSA3TumA1}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumA1.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA3TumA1_SCT.Rdata")

```

## BCSA3TumA2

```{r BCSA3TumA2}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumA2.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA3TumA2_SCT.Rdata")


```

## BCSA3TumB1

```{r BCSA3TumB1}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumB1.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA3TumB1_SCT.Rdata")


```

## BCSA3TumB2

```{r BCSA3TumB2}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumB2.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA3TumB2_SCT.Rdata")


```

## BCSA3TumC1

```{r BCSA3TumC1}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumC1.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA3TumC1_SCT.Rdata")


```

## BCSA3TumC2

```{r BCSA3TumC2}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumC2.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA3TumC2_SCT.Rdata")

```

## BCSA3TumD1

```{r BCSA3TumD1}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumD1.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA3TumD1_SCT.Rdata")


```

## BCSA3TumD2

```{r BCSA3TumD2}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumD2.RData")

# Filter the low quality spots and find highly variable genes
bcsa <- subset(bcsa, subset = nFeature_Spatial > 500 & percent_mito < 25 & percent_hb < 0.2)

# QC
p1 <- VlnPlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito"), pt.size = 0.1) + NoLegend()
p2 <- SpatialFeaturePlot(bcsa, features = c("nCount_Spatial", "nFeature_Spatial", "percent_mito")) 

# Normalization
bcsa <- SCTransform(bcsa, assay = "Spatial", verbose = F, vars.to.regress = "percent_mito")

# Expression of ER, PGR, ERBB2, MKI67
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), alpha = c(0.1, 1))

# Dimensionality reduction, clustering, visualization
bcsa <- RunPCA(bcsa, assay = "SCT", npcs = 50)
ElbowPlot(bcsa, ndims = 50)

bcsa <- FindNeighbors(bcsa, reduction = "pca", dims = 1:30)
for (i in seq(from = 0.1, to = 1, by = 0.1)) {
  bcsa <- FindClusters(bcsa, resolution = i)
  bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)
  print(SpatialDimPlot(object = bcsa, group.by = "ident", label = TRUE, pt.size=1, repel = TRUE))
}

bcsa <- FindClusters(bcsa, resolution = 0.6)
bcsa <- RunUMAP(object = bcsa, reduction = "pca", dims = 1:30, seed.use = 100)

DimPlot(bcsa, reduction = "umap", label = T)
SpatialDimPlot(bcsa, label = T, alpha = c(0.3, 1))

SpatialDimPlot(bcsa, cells.highlight = CellsByIdentities(object = bcsa, idents = c(0, 1)), 
               facet.highlight = TRUE, ncol = 2, alpha = c(0.3, 1))

# Identify spatially variable features
# FindSpatiallyVariables(), is to search for features exhibiting spatial patterning in the absence of pre-annotation. The default method (method = 'markvariogram), is inspired by the Trendsceek, which models spatial transcriptomics data as a mark point process and computes a ‘variogram’, which identifies genes whose expression level is dependent on their spatial location. More specifically, this process calculates gamma (r) values measuring the dependence between two spots a certain “r” distance apart. 

# By default, we use an r-value of ‘5’ in these analyses, and only compute these values for variable genes (where variation is calculated independently of spatial location) to save time.

# We note that there are multiple methods in the literature to accomplish this task, including SpatialDE, and Splotch. 
#bcsa <- FindSpatiallyVariableFeatures(bcsa, assay = "SCT", features = VariableFeatures(bcsa)[1:1000],
#                                      selection.method = "moransi")
SpatialDimPlot(bcsa, group.by = "SCT_snn_res.0.6", alpha = c(0.2, 1))

save(bcsa, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA3TumD2_SCT.Rdata")

```


## BCSA3 integration

```{r BCSA3 integration}

load("~/Desktop/CIIR/results/colocalization/BCSA3TumA1_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumA1", Cells(bcsa), sep = "_"))
bcsaTuma1 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA3TumA2_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumA2", Cells(bcsa), sep = "_"))
bcsaTuma2 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA3TumB1_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumB1", Cells(bcsa), sep = "_"))
bcsaTumb1 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA3TumB2_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumB2", Cells(bcsa), sep = "_"))
bcsaTumb2 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA3TumC1_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumC1", Cells(bcsa), sep = "_"))
bcsaTumc1 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA3TumC2_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumC2", Cells(bcsa), sep = "_"))
bcsaTumc2 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA3TumD1_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumD1", Cells(bcsa), sep = "_"))
bcsaTumd1 <- bcsa

load("~/Desktop/CIIR/results/colocalization/BCSA3TumD2_SCT.Rdata")
bcsa <- RenameCells(bcsa, new.names = paste("TumD2", Cells(bcsa), sep = "_"))
bcsaTumd2 <- bcsa

# Merge replicates first, merge does not support merging 4 samples at a time
bcsaTuma <- merge(bcsaTuma1, bcsaTuma2)
bcsaTumb <- merge(bcsaTumb1, bcsaTumb2)
bcsaTumc <- merge(bcsaTumc1, bcsaTumc2)
bcsaTumd <- merge(bcsaTumd1, bcsaTumd2)

bcsa3 <- merge(bcsaTuma, bcsaTumb)
bcsa3 <- merge(bcsa3, bcsaTumc)
bcsa3 <- merge(bcsa3, bcsaTumd)

# split by original identity
ob_list <- SplitObject(bcsa3, split.by = "orig.ident")

ob_list <- lapply(ob_list, FUN = function(x) {
  x <- NormalizeData(x, normalization.method = "LogNormalize", scale.factor = 10000)
  x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 5000)
})

# select features that repeatedly variable across datasets for integration
features <- SelectIntegrationFeatures(object.list = ob_list) 

# For RPCA integration only
ob_list <- lapply(X = ob_list, FUN = function(x) {
    x <- ScaleData(x, features = features, verbose = FALSE)
    x <- RunPCA(x, features = features, verbose = FALSE)
})

anchors <- FindIntegrationAnchors(object.list = ob_list, anchor.features = features, reduction = "rpca")
bcsa3 <- IntegrateData(anchorset = anchors)

DefaultAssay(bcsa3) <- "integrated"

bcsa3 <- bcsa3 %>% 
  #FindVariableFeatures() %>% 
  ScaleData(vars.to.regress = "percent_mito") %>% 
  RunNMF(nfactors = 20) %>% 
  FindNeighbors(dims = 1:20, reduction = "NMF")
bcsa3 <- FindClusters(bcsa3, resolution = 0.4, cluster.name = "integrated_clusters") %>% 
  RunUMAP(dims = 1:20, reduction = "NMF", reduction.name = "umap")
DimPlot(bcsa3, reduction = "umap", group.by = c("orig.ident", "integrated_clusters"))

SpatialDimPlot(bcsa3, ncol = 4, alpha = 1)F
#SpatialDimPlot(bcsa3, ncol = 4, alpha = 0)

################ Differential expression analysis to find markers
#cluster_markers <- FindAllMarkers(bcsa3, only.pos = T, test.use = "roc")

#markers <- cluster_markers %>% dplyr::group_by(cluster) %>% top_n(wt = power, 15)

cluster_markers_wilcox <- FindAllMarkers(bcsa3, only.pos = T, test.use = "wilcox") %>% 
  dplyr::group_by(cluster) %>% 
  top_n(wt = avg_log2FC, 50)

markers <- cluster_markers_wilcox %>% dplyr::group_by(cluster) %>% top_n(wt = avg_log2FC, 15)

col = c("0" = "#3C77AF",
        "1" = "#7DBFA7", "2" = "#EE934E", "4" = "#AECDE1",
        "3" = "#D1352B", "9" = "#F5CFE4", 
        "5" = "#FCED82", "7" = "#B383B9", "8" = "#BBDD78", "6" = "grey", "9" = "#429948", "10" = "#7A2C2C")
SpatialDimPlot(bcsa3, group.by = "ident", ncol = 4, cols = col) 
DimPlot(bcsa3, reduction = "umap", group.by = "orig.ident")
DimPlot(bcsa3, reduction = "umap", group.by = "integrated_clusters", cols = col)

# Plot the DEGs in each cluster
DoHeatmap(bcsa3, features = markers$gene, group.by = "ident",
          group.colors = col, slot = "scale.data", angle = 0, raster = F)

# Percentage of each cluster in different tumor region
df <- table(bcsa3@meta.data$orig.ident, bcsa3@meta.data$integrated_clusters) %>% as.data.frame()
df <- df %>% group_by(Var1) %>% mutate(total = sum(Freq))
df$percent <- df$Freq / df$total
colnames(df)[2] <- "Clusters"

ggplot(df, aes(x = "", y = percent, fill = Clusters)) + geom_bar(stat = "identity") + 
  coord_polar("y", start = 0) + 
  theme_bw() + xlab("") + ylab("") +
  facet_wrap(~Var1, ncol = 4) + scale_fill_manual(values = col)

# Rename Identity
bcsa3 <- RenameIdents(bcsa3, "0" = "Low-density_area (Stroma-Immune)", "1" = "Tumor-Immune", "2" = "Stroma-Immune",
                      "3" = "Tumor", "4" = "Tumor", "5" = "Stroma-Immune", "6" = "Immune",
                      "7" = "Tumor", "8" = "Stroma-Immune", "9" = "Low-density_area (Stroma-Immune)", 
                      "10" = "Low-density_area (Stroma)")
bcsa3 <- AddMetaData(bcsa3, bcsa3@active.ident, col.name = "Annotated_clusters")

col = c("Tumor" = "#429948", "Tumor-Immune" = "#BBDD78", "Stroma-Immune" = "#FCED82",
         "Immune" = "#FFDE18", "Stroma" = "#9BCCE3", "Low-density_area (Stroma)" = "#9BCCE3",
        "Low-density_area (Stroma-Immune)" = "#9BCCE3")
SpatialDimPlot(bcsa3, group.by = "Annotated_clusters", ncol = 4, cols = col, image.alpha = 0) +
  plot_layout(guides = "collect")

################## Identify RegionNeighbors using semla package

# Update seurat object to be used in semla package
bcsa3 <- UpdateSeuratForSemla(bcsa3)

# Identify tumor edge by using inner mode
bcsa3 <- RegionNeighbors(bcsa3, column_name = "Annotated_clusters", column_labels = "Tumor",
                              mode = "inner")

# Identify neighbors next to tumor cluster
bcsa3 <- RegionNeighbors(bcsa3, column_name = "Annotated_clusters", column_labels = "Tumor")

# Identify neighbors within and next to tumor cluster
bcsa3 <- RegionNeighbors(bcsa3, column_name = "Annotated_clusters", column_labels = "Tumor",
                              mode = "all_inner_outer", column_key = "all_nb_to_")

#################### Check correlation between digital pathology and deconvolution on tumor edge

# Get the cell2location deconvolution results
decon <- data.frame()
gro <- names(bcsa3@images)[-4]
for (i in gro) {
  temp1 <- read.csv(paste0("/Users/tili/Desktop/CIIR/results/cell2location/Merged_correlation_results/", 
                           i, "_correlation_matrix.csv"))
  region <- gsub("BCSA3", "", i)
  temp1$X <- paste0(region, "_", temp1$X)
  decon <- rbind(decon, temp1)
}

# Filter out the tumor edge spots - Remove BCSA3TumB2
edge <- bcsa3@meta.data %>% 
  dplyr::filter(orig.ident != "BCSA3TumB2") %>% 
  dplyr::select(orig.ident, Annotated_clusters, inner_border_Tumor) %>% 
  na.omit() %>% 
  mutate(cellid = rownames(.))

# Filter out spots next to tumor cluster - Remove BCSA3TumB2
outside <- bcsa3@meta.data %>% 
  dplyr::filter(orig.ident != "BCSA3TumB2") %>% 
  dplyr::select(orig.ident, Annotated_clusters, nb_to_Tumor) %>% 
  na.omit() %>% 
  mutate(cellid = rownames(.))

# Filter out spots within and outside tumor cluster - Remove BCSA3TumB2
all_spot <- bcsa3@meta.data %>% 
  dplyr::filter(orig.ident != "BCSA3TumB2") %>% 
  dplyr::select(orig.ident, Annotated_clusters, all_nb_to_Tumor) %>% 
  na.omit() %>% 
  mutate(cellid = rownames(.))
inner <- all_spot[-which(all_spot$cellid %in% edge$cellid | all_spot$cellid %in% outside$cellid),]

decon_edge <- decon[which(decon$X %in% edge$cellid),]
decon_inner <- decon[-which(decon$X %in% inner$cellid),]

# Correlation on tumor edge
p1 <- ggplot(decon_edge, aes(x = tumor_cel2, y = tumor_per)) + geom_point() + theme_bw() +
    ggtitle(paste0("Cell2location: Tumor edge correlation")) + geom_smooth(method = "lm") + 
  ggpubr::stat_cor(method = "spearman")

p2 <- ggplot(decon_inner, aes(x = tumor_cel2, y = tumor_per)) + geom_point() + theme_bw() +
    ggtitle(paste0("Cell2location: Tumor inner part correlation")) + geom_smooth(method = "lm") + 
  ggpubr::stat_cor(method = "spearman")
p1 + p2

################## Check what cluster is next to each tumor cluster

# Identify neighbors next to tumor cluster 1, 3, 4, 7
bcsa3 <- RegionNeighbors(bcsa3, column_name = "integrated_clusters", column_labels = "1", 
                         column_key = "nb_to_tumor_")
bcsa3 <- RegionNeighbors(bcsa3, column_name = "integrated_clusters", column_labels = "3", 
                         column_key = "nb_to_tumor_")
bcsa3 <- RegionNeighbors(bcsa3, column_name = "integrated_clusters", column_labels = "4", 
                         column_key = "nb_to_tumor_")
bcsa3 <- RegionNeighbors(bcsa3, column_name = "integrated_clusters", column_labels = "7", 
                         column_key = "nb_to_tumor_")

temp1 <- data.frame()
for (i in names(bcsa3@images)) {
  temp1.cel2 <- read.csv(paste0("/Users/tili/Desktop/CIIR/results/cell2location/", 
                           i, "_q05.csv"))
  colnames(temp1.cel2) <- gsub("q05cell_abundance_w_sf_", "", colnames(temp1.cel2))
  
  # Normalize cell type proportion so that the proportion adds up to 1
  temp1.cell2 <- rowSums(temp1.cel2[,-1]) %>% as.data.frame() %>% 'colnames<-' ("RowSum")
  temp1.cell2$X <- temp1.cel2$X
  for (k in 2:ncol(temp1.cel2)) {
    temp1.cell2[,k+1] <- temp1.cel2[,k] / temp1.cell2$RowSum
    colnames(temp1.cell2)[k+1] <- colnames(temp1.cel2)[k]
  }
  temp1.cel2 <- temp1.cell2[,-1]
  
  sec_id <- gsub("BCSA3", "", i)
  rownames(temp1.cel2) <- paste0(sec_id, "_", temp1.cel2$X)
  temp1.cel2 <- temp1.cel2[,-1]
  
  temp1 <- rbind(temp1, temp1.cel2)
}

nb <- bcsa3@meta.data %>% dplyr::select(nb_to_tumor_1, nb_to_tumor_3, nb_to_tumor_4, nb_to_tumor_7)
nb$spotid <- rownames(nb)

# Filter out tumor 1 neighbors
t1_nb <- nb[,c(1,5)] %>% na.omit()
t1 <- temp1[which(rownames(temp1) %in% t1_nb$spotid),]

# Plot colocalization/interactions
SPOTlight::plotInteractions(as.matrix(t1), which = "network")

# Filter out tumor 3 neighbor
t3_nb <- nb[,c(2,5)] %>% na.omit()
t3 <- temp1[which(rownames(temp1) %in% t3_nb$spotid),]

SPOTlight::plotInteractions(as.matrix(t3), which = "network")

# Filter out tumor 4 neighbor
t4_nb <- nb[,c(3,5)] %>% na.omit()
t4 <- temp1[which(rownames(temp1) %in% t4_nb$spotid),]

SPOTlight::plotInteractions(as.matrix(t4), which = "network")

# Filter out tumor 7 neighbor
t7_nb <- nb[,c(4,5)] %>% na.omit()
t7 <- temp1[which(rownames(temp1) %in% t7_nb$spotid),]

SPOTlight::plotInteractions(as.matrix(t7), which = "network")

# Plot colocalization/interactions in the whole section
SPOTlight::plotInteractions(as.matrix(temp1), which = "network")

################## GSVA on the sub-clusters

Idents(bcsa3) <- bcsa3@meta.data$integrated_clusters

# Aggregate expression in each cluster
pseudo_bcsa3 <- AggregateExpression(bcsa3, assays = "Spatial", return.seurat = T, group.by = "integrated_clusters")

# Extract data matrix from the counts slot
pseudo_matrix <- GetAssayData(pseudo_bcsa3, assay = "Spatial", layer = "counts") %>% as.data.frame()

# Normalization
normalized_pseudo <- edgeR::cpm(pseudo_matrix, normalized.lib.sizes = T, log = T)

# Hallmark gene set
geneset <- GSEABase::getGmt("/Users/tili/Desktop/CIIR/data/h.all.v2024.1.Hs.symbols.gmt")

# GSVA analysis
# kcdf value "Gaussian" is suitable for continuous expression data, such as microarray fluorescent units in logarithmic scale and 
# RNA-seq log-CPMs, log-RPKMs or log-TPMs units of expression; "Poisson" is suitable for integer counts, such as those 
# derived from RNA-seq alignments
gsvaPar <- gsvaParam(as.matrix(normalized_pseudo), geneset, kcdf = "Gaussian")
gsva.es <- gsva(gsvaPar, verbose=FALSE)

ComplexHeatmap::Heatmap(gsva.es,
        cluster_columns = T,
        cluster_rows = T,
        show_row_names = T,
        show_column_names = T,
        clustering_distance_rows = "euclidean",
        color = colorRampPalette(c("blue", "white", "red"))(100))

######################### DE analysis on different tumor clusters

Idents(bcsa3) <- bcsa3@meta.data$integrated_clusters
t1_vs_t3 <- FindMarkers(bcsa3, ident.1 = "1", ident.2 = "3")
t1_vs_t3$gene <- rownames(t1_vs_t3)

# Get entrez id
entrez <- clusterProfiler::bitr(rownames(t1_vs_t3), fromType = "SYMBOL", 
                                         toType = "ENTREZID", OrgDb = org.Hs.eg.db)
t1_vs_t3 <- merge(t1_vs_t3, entrez, by.x = "gene", by.y = "SYMBOL", all.x = F)

# Create a genelist for gseGO analysis
genelist <- t1_vs_t3$avg_log2FC
names(genelist) <- t1_vs_t3$ENTREZID
genelist <- sort(genelist, decreasing = T)

# gseGO analysis
go <- gseGO(genelist, ont = "BP", OrgDb = org.Hs.eg.db, 
            keyType = "ENTREZID", minGSSize = 10, maxGSSize = 500,
            pvalueCutoff = 0.05, pAdjustMethod = "BH")
go <- setReadable(go, OrgDb = org.Hs.eg.db,keyType = "ENTREZID")

# Plot gseGO results, cluster the top30 GOs
go2 <- pairwise_termsim(go)
treeplot(go2, showCategory = 30, color = "NES") + ggtitle("BCSA3 Tumor 1 vs 3") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4, 4))
openxlsx::write.xlsx(go2@result, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA3_tumor_cluster_1_vs_3_gseGO_20241015.xlsx")

### t1 vs t4 cluster
t1_vs_t4 <- FindMarkers(bcsa3, ident.1 = "1", ident.2 = "4")
t1_vs_t4$gene <- rownames(t1_vs_t4)

# Get entrez id
entrez <- clusterProfiler::bitr(rownames(t1_vs_t4), fromType = "SYMBOL", 
                                         toType = "ENTREZID", OrgDb = org.Hs.eg.db)
t1_vs_t4 <- merge(t1_vs_t4, entrez, by.x = "gene", by.y = "SYMBOL", all.x = F)

# Create a genelist for gseGO analysis
genelist <- t1_vs_t4$avg_log2FC
names(genelist) <- t1_vs_t4$ENTREZID
genelist <- sort(genelist, decreasing = T)

# gseGO analysis
go <- gseGO(genelist, ont = "BP", OrgDb = org.Hs.eg.db, 
            keyType = "ENTREZID", minGSSize = 10, maxGSSize = 500,
            pvalueCutoff = 0.05, pAdjustMethod = "BH")
go <- setReadable(go, OrgDb = org.Hs.eg.db,keyType = "ENTREZID")

# Plot gseGO results, cluster the top30 GOs
go2 <- pairwise_termsim(go)
treeplot(go2, showCategory = 30, color = "NES") + ggtitle("BCSA3 Tumor 1 vs 4") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4, 4))
openxlsx::write.xlsx(go2@result, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA3_tumor_cluster_1_vs_4_gseGO_20241015.xlsx")

### t1 vs t7 cluster
t1_vs_t7 <- FindMarkers(bcsa3, ident.1 = "1", ident.2 = "7")
t1_vs_t7$gene <- rownames(t1_vs_t7)

# Get entrez id
entrez <- clusterProfiler::bitr(rownames(t1_vs_t7), fromType = "SYMBOL", 
                                         toType = "ENTREZID", OrgDb = org.Hs.eg.db)
t1_vs_t7 <- merge(t1_vs_t7, entrez, by.x = "gene", by.y = "SYMBOL", all.x = F)

# Create a genelist for gseGO analysis
genelist <- t1_vs_t7$avg_log2FC
names(genelist) <- t1_vs_t7$ENTREZID
genelist <- sort(genelist, decreasing = T)

# gseGO analysis
go <- gseGO(genelist, ont = "BP", OrgDb = org.Hs.eg.db, 
            keyType = "ENTREZID", minGSSize = 10, maxGSSize = 500,
            pvalueCutoff = 0.05, pAdjustMethod = "BH")
go <- setReadable(go, OrgDb = org.Hs.eg.db,keyType = "ENTREZID")

# Plot gseGO results, cluster the top30 GOs
go2 <- pairwise_termsim(go)
treeplot(go2, showCategory = 30, color = "NES") + ggtitle("BCSA3 Tumor 1 vs 7") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4, 4))
openxlsx::write.xlsx(go2@result, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA3_tumor_cluster_1_vs_7_gseGO_20241015.xlsx")

### t3 vs t7 cluster
t3_vs_t7 <- FindMarkers(bcsa3, ident.1 = "3", ident.2 = "7")
t3_vs_t7$gene <- rownames(t3_vs_t7)

# Get entrez id
entrez <- clusterProfiler::bitr(rownames(t3_vs_t7), fromType = "SYMBOL", 
                                         toType = "ENTREZID", OrgDb = org.Hs.eg.db)
t3_vs_t7 <- merge(t3_vs_t7, entrez, by.x = "gene", by.y = "SYMBOL", all.x = F)

# Create a genelist for gseGO analysis
genelist <- t3_vs_t7$avg_log2FC
names(genelist) <- t3_vs_t7$ENTREZID
genelist <- sort(genelist, decreasing = T)

# gseGO analysis
go <- gseGO(genelist, ont = "BP", OrgDb = org.Hs.eg.db, 
            keyType = "ENTREZID", minGSSize = 10, maxGSSize = 500,
            pvalueCutoff = 0.05, pAdjustMethod = "BH")
go <- setReadable(go, OrgDb = org.Hs.eg.db,keyType = "ENTREZID")

# Plot gseGO results, cluster the top30 GOs
go2 <- pairwise_termsim(go)
treeplot(go2, showCategory = 30, color = "NES") + ggtitle("BCSA3 Tumor 3 vs 7") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4, 4))
openxlsx::write.xlsx(go2@result, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA3_tumor_cluster_3_vs_7_gseGO_20241015.xlsx")

### t3 vs t4 cluster
t3_vs_t4 <- FindMarkers(bcsa3, ident.1 = "3", ident.2 = "4")
t3_vs_t4$gene <- rownames(t3_vs_t4)

# Get entrez id
entrez <- clusterProfiler::bitr(rownames(t3_vs_t4), fromType = "SYMBOL", 
                                         toType = "ENTREZID", OrgDb = org.Hs.eg.db)
t3_vs_t4 <- merge(t3_vs_t4, entrez, by.x = "gene", by.y = "SYMBOL", all.x = F)

# Create a genelist for gseGO analysis
genelist <- t3_vs_t4$avg_log2FC
names(genelist) <- t3_vs_t4$ENTREZID
genelist <- sort(genelist, decreasing = T)

# gseGO analysis
go <- gseGO(genelist, ont = "BP", OrgDb = org.Hs.eg.db, 
            keyType = "ENTREZID", minGSSize = 10, maxGSSize = 500,
            pvalueCutoff = 0.05, pAdjustMethod = "BH")
go <- setReadable(go, OrgDb = org.Hs.eg.db,keyType = "ENTREZID")

# Plot gseGO results, cluster the top30 GOs
go2 <- pairwise_termsim(go)
treeplot(go2, showCategory = 30, color = "NES") + ggtitle("BCSA3 Tumor 3 vs 4") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4, 4))
openxlsx::write.xlsx(go2@result, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA3_tumor_cluster_3_vs_4_gseGO_20241015.xlsx")

### t4 vs t7 cluster
t4_vs_t7 <- FindMarkers(bcsa3, ident.1 = "4", ident.2 = "7")
t4_vs_t7$gene <- rownames(t4_vs_t7)

# Get entrez id
entrez <- clusterProfiler::bitr(rownames(t4_vs_t7), fromType = "SYMBOL", 
                                         toType = "ENTREZID", OrgDb = org.Hs.eg.db)
t4_vs_t7 <- merge(t4_vs_t7, entrez, by.x = "gene", by.y = "SYMBOL", all.x = F)

# Create a genelist for gseGO analysis
genelist <- t4_vs_t7$avg_log2FC
names(genelist) <- t4_vs_t7$ENTREZID
genelist <- sort(genelist, decreasing = T)

# gseGO analysis
go <- gseGO(genelist, ont = "BP", OrgDb = org.Hs.eg.db, 
            keyType = "ENTREZID", minGSSize = 10, maxGSSize = 500,
            pvalueCutoff = 0.05, pAdjustMethod = "BH")
go <- setReadable(go, OrgDb = org.Hs.eg.db,keyType = "ENTREZID")

# Plot gseGO results, cluster the top30 GOs
go2 <- pairwise_termsim(go)
treeplot(go2, showCategory = 30, color = "NES") + ggtitle("BCSA3 Tumor 4 vs 7") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", limits = c(-4, 4))
openxlsx::write.xlsx(go2@result, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA3_tumor_cluster_4_vs_7_gseGO_20241015.xlsx")

save(bcsa3, file = "/Users/tili/Desktop/CIIR/results/colocalization/BCSA3_merge.Rdata")

########################### UMAP colored by QuPath annotation ###############

umap_em <- bcsa3@reductions$umap@cell.embeddings %>% as.data.frame()
umap_em$spotid <- rownames(umap_em)

# Merge UMAP coordinates with QuPath classification results
umap_em <- merge(umap_em, decon, by.x = "spotid", by.y = "X", all.x = F, all.y = T)

# Plot UMAP
tumor_color <- "#D2817E"  # Custom reddish color
immune_color <- "#FFDE18" # Custom yellowish color
stroma_color <- "#9BCCE3" # Custom bluish color

# Create a color ramp function for each custom color
tumor_ramp <- colorRamp(c("black", tumor_color))
immune_ramp <- colorRamp(c("black", immune_color))
stroma_ramp <- colorRamp(c("black", stroma_color))

# Blend custom colors based on the proportions
umap_em$custom_color <- apply(
  umap_em[, c("tumor_per", "immune_per", "stroma_per")], 1, function(row) {
    # Weighted blending of tumor, immune, and stroma colors
    blended <- tumor_ramp(row["tumor_per"]) +
               immune_ramp(row["immune_per"]) +
               stroma_ramp(row["stroma_per"])
    blended <- blended / max(blended) * 255  # Normalize to keep within 0–255 range
    rgb(blended[1] / 255, blended[2] / 255, blended[3] / 255) # Convert to hex
  }
)

# Plot the UMAP with the custom blended colors
ggplot(umap_em, aes(x = umap_1, y = umap_2, col = custom_color)) +
  geom_point(size = 0.3) + 
  scale_colour_identity() +
  new_scale_color() +
  geom_point(aes(col = tumor_per), shape = NA) +
  scale_color_gradient(low = "black", high = "#D2817E") +
  new_scale_color() +
  geom_point(aes(col = immune_per), shape = NA) +
  scale_color_gradient(low = "black", high = "#FFDE18") +
  new_scale_color() +
  geom_point(aes(col = stroma_per), shape = NA) +
  scale_color_gradient(low = "black", high = "#9BCCE3") +
  new_scale_color() + theme_bw() +
  xlab("UMAP1") + ylab("UMAP2")

```

## BCSA3 QuPath cell percentage in different tumor clusters

```{r BCSA3 QuPath cell percent in tumor clusters}

qupath <- read.csv("/Users/tili/Desktop/CIIR/results/Cell_annotation_qupath_analyzed/cell_qupath_combined_20241014.csv")
qupath$spot <- paste0(str_sub(qupath$id, start = 6), "_", qupath$cellid)
qupath$patient <- str_sub(qupath$id, end = 5)

# Extract tumor spot id
df <- bcsa3@meta.data %>% dplyr::select(orig.ident, integrated_clusters)

# Filter out spot id for tumor clusters
#spotid <- df[which(df$integrated_clusters == 3 | df$integrated_clusters == 4 | 
#                        df$integrated_clusters == 7),]

# Use spots in all clusters
spotid <- df
spotid$spot <- rownames(spotid)

bcsa3_tumor <- qupath[which(qupath$spot %in% spotid$spot & qupath$patient == "BCSA3"),]
bcsa3_tumor <- merge(bcsa3_tumor, spotid, by.x = "spot", by.y = "spot")

# Calculate the percent of tumor, immune, and stroma in each cluster
bcsa3_freq <- bcsa3_tumor %>% dplyr::group_by(integrated_clusters) %>% 
  dplyr::count(Classification) %>% 
  dplyr::filter(Classification != "")

bcsa3_freq <- bcsa3_freq %>% dplyr::group_by(integrated_clusters) %>% mutate(Total = sum(n))
bcsa3_freq$Percent <- bcsa3_freq$n / bcsa3_freq$Total
bcsa3_freq$Cluster <- paste0("Cluster", bcsa3_freq$integrated_clusters)

bcsa3_freq$Cluster <- factor(bcsa3_freq$Cluster, levels = c("Cluster0", "Cluster1", "Cluster2",
                                                            "Cluster3", "Cluster4", "Cluster5",
                                                            "Cluster6", "Cluster7", "Cluster8",
                                                            "Cluster9", "Cluster10"))

bcsa3_freq$spot_n <- rep(table(bcsa3@meta.data$integrated_clusters), each = 3)
bcsa3_freq$spot_density <- round(bcsa3_freq$Total / bcsa3_freq$spot_n, 2)

# Plot the cell type percent in each tumor cluster
ggplot(bcsa3_freq, aes(x = Cluster, y = Percent, fill = Classification)) + 
  geom_bar(stat = "identity", position = "stack") + theme_bw() +
  scale_fill_manual(values = c("Tumor" = "#429948", 
          "Immune cells" = "#FFDE18", "Stroma" = "#9BCCE3")) + xlab("") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

## Plot BCSA3 inferCNV results

```{r BCSA3 inferCNV}
  
cnv <- readRDS("/Users/tili/Desktop/CIIR/results/infercnv/BCSA3_i3/run.final.scaled.infercnv_obj")

# infercnv_obj@expr.data is the scaled cnv number for each dot in column and gene in row;
# infercnv_obj@gene_order is the gene location, chr, start and end.

bcsa3_cnv_matrix <- cnv@expr.data
gene_order <- cnv@gene_order
gene_order$gene <- rownames(gene_order)

meta <- bcsa3@meta.data %>% dplyr::select(integrated_clusters, orig.ident)
meta$spotid <- rownames(meta)
meta <- meta[which(meta$spotid %in% colnames(bcsa3_cnv_matrix)),]

col = c("0" = "#3C77AF",
        "1" = "#7DBFA7", "2" = "#EE934E", "4" = "#AECDE1",
        "3" = "#D1352B", "9" = "#F5CFE4", 
        "5" = "#FCED82", "7" = "#B383B9", "8" = "#BBDD78", "6" = "grey", "9" = "#429948", "10" = "#7A2C2C")
ha <- HeatmapAnnotation(Cluster = meta$integrated_clusters, col = list(Cluster = col))

col_fun <- colorRamp2(
  breaks = c(0.8, 1, 1.2),  # Values to map
  colors = c("blue", "white", "red")  # Colors corresponding to the values
)

# Cluster by column (integrated clusters)
Heatmap(bcsa3_cnv_matrix, cluster_rows = F, 
        show_row_names = F, show_column_names = F,
        row_split = gene_order$chr, 
        top_annotation = ha, col = col_fun, 
        column_split = meta$integrated_clusters, cluster_column_slices = T)

# Save results
write.csv(bcsa3_cnv_matrix, file = "/Users/tili/Desktop/CIIR/results/infercnv/BCSA3_i3/bcsa3_cnv_matrix.csv")
write.csv(gene_order, file = "/Users/tili/Desktop/CIIR/results/infercnv/BCSA3_i3/gene_order.csv")

# Extract meta data
normal <- read.delim("/Users/tili/Desktop/CIIR/results/infercnv/BCSA3_ref_spot.txt", header = F)
normal$type <- rep("Normal", nrow(normal))
tumor <- read.delim("/Users/tili/Desktop/CIIR/results/infercnv/BCSA3_filtered_tumor_40_percent_spots_rep1_for_inferCNV.txt", header = F)
tumor$type <- rep("Tumor", nrow(tumor))
spots <- rbind(normal, tumor)
spots <- spots[which(spots$V1 %in% colnames(bcsa3_cnv_matrix)),]

tumor_matrix <- bcsa3_cnv_matrix[, which(colnames(bcsa3_cnv_matrix) %in% tumor$V1)]

# Cluster by clone
hm <- Heatmap(as.matrix(tumor_matrix), cluster_rows = F, 
              show_row_names = F, show_column_names = F, cluster_columns = T,
              col = col_fun, 
              border = F,
              clustering_method_columns = "ward.D",
              row_split = gene_order$chr
)

# Extract dendrogram for each cluster
col_order_list <- column_dend(hm)

# Cut tree at height 150 to get 3 clusters
dend1 <- col_order_list[[1]]
temp1 <- cutree(dend1, h = 205) %>% as.data.frame()
temp1$cluster <- ifelse(str_detect(temp1$., "1"), "A", "B")
clone1 <- temp1$cluster
names(clone1) <- rownames(temp1)

dend2 <- col_order_list[[2]]
temp1 <- cutree(dend2, h = 205) %>% as.data.frame()
temp1$cluster <- dplyr::recode(temp1$., `1` = "C", `2` = "D")#
#, `3` = "E", `4` = "F", `5` = "G", `6` = "H")
clone2 <- temp1$cluster
names(clone2) <- rownames(temp1)

clone <- c(clone1, clone2)

# Add results to bcsa meta data
bcsa <- subset(bcsa3, orig.ident %in% c("BCSA3TumA1", "BCSA3TumB1", "BCSA3TumC1", "BCSA3TumD1"))
bcsa <- subset(bcsa, cells = names(clone))
bcsa <- AddMetaData(bcsa, clone, col.name = "inferCNV")
co <- c("A" = "#35A153", "B" = "#FFCD44", "C" = "#1d9bf7", "D" = "#d95f0e", 
        "E" = "#c51b7d", "F" = "#bf812d", "G" = "#35978f", "H" = "#878787")
SpatialDimPlot(bcsa, group.by = "inferCNV", cols = co, ncol = 2)

# Plot heatmap with clone information
clones <- as.data.frame(clone)
clones$spotid <- rownames(clones)
clones <- merge(clones, meta, by.x = "spotid", by.y = "spotid", all.x = T, all.y = F)

# Sankey plot
df2 <- clones %>% make_long(integrated_clusters, clone)
col = c("0" = "#3C77AF",
                "1" = "#7DBFA7", "2" = "#EE934E", "4" = "#AECDE1",
                "3" = "#D1352B", "9" = "#F5CFE4", 
                "5" = "#FCED82", "7" = "#B383B9", "8" = "#BBDD78", "6" = "grey", "9" = "#429948", "10" = "#7A2C2C",
        "A" = "#35A153", "B" = "#FFCD44", "C" = "#1d9bf7", "D" = "#d95f0e",
        "E" = "#c51b7d", "F" = "#bf812d", "G" = "#35978f", "H" = "#878787")
ggplot(df2, aes(x = x, 
                next_x = next_x, 
                node = node, 
                next_node = next_node,
                fill = factor(node))) +
  geom_sankey(flow.alpha = .6,
              node.color = "gray30") +
  geom_sankey_label(aes(label = node), size = 3, color = "white") +
  scale_fill_manual(values = col, drop = FALSE) +
  theme_sankey(base_size = 18) +
  labs(x = NULL) +
  theme(legend.position = "none",
        plot.title = element_text(hjust = .5))

ha <- HeatmapAnnotation(Cluster = clones$integrated_clusters, col = list(Cluster = col))
ba <- rowAnnotation(Clone = clones$clone, col = list(Clone = co))

col_ha <- HeatmapAnnotation(foo = anno_mark(at = which(colnames(t(tumor_matrix)) %in% c("ERBB2")),
                                            labels = c("ERBB2")))

pdf(file = "/Users/tili/Desktop/CIIR/results/inferCNV/BCSA3_inferCNV_heatmap_4_clones.pdf", width = 18, height = 9)
Heatmap(t(as.matrix(tumor_matrix)), cluster_rows = T, 
        show_row_names = F, show_column_names = F, cluster_columns = F,
        col = col_fun, 
        row_split = clones$clone,
        left_annotation = ba,
        bottom_annotation = col_ha,
        clustering_method_rows = "ward.D",
        column_split = gene_order$chr
)
dev.off()
```

## BCSA3 PAM50

```{r BCSA3 PAM50}

# load PAM50 results
load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumA1_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumA1", Cells(bcsa), sep = "_"))
bcsaTuma1 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumA2_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumA2", Cells(bcsa), sep = "_"))
bcsaTuma2 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumB1_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumB1", Cells(bcsa), sep = "_"))
bcsaTumb1 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumB2_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumB2", Cells(bcsa), sep = "_"))
bcsaTumb2 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumC1_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumC1", Cells(bcsa), sep = "_"))
bcsaTumc1 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumC2_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumC2", Cells(bcsa), sep = "_"))
bcsaTumc2 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumD1_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumD1", Cells(bcsa), sep = "_"))
bcsaTumd1 <- bcsa

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumD2_processed.RData")
bcsa <- RenameCells(bcsa, new.names = paste("TumD2", Cells(bcsa), sep = "_"))
bcsaTumd2 <- bcsa

# Merge replicates first, merge does not support merging 4 samples at a time
bcsaTuma <- merge(bcsaTuma1, bcsaTuma2)
bcsaTumb <- merge(bcsaTumb1, bcsaTumb2)
bcsaTumc <- merge(bcsaTumc1, bcsaTumc2)
bcsaTumd <- merge(bcsaTumd1, bcsaTumd2)

bcsa3_pam50 <- merge(bcsaTuma, bcsaTumb)
bcsa3_pam50 <- merge(bcsa3_pam50, bcsaTumc)
bcsa3_pam50 <- merge(bcsa3_pam50, bcsaTumd)

# Aggregate deconvolution results
temp1 <- data.frame()
for (i in names(bcsa3@images)) {
  temp1.cel2 <- read.csv(paste0("/Users/tili/Desktop/CIIR/results/cell2location/", i, "_q05.csv"))
  colnames(temp1.cel2) <- gsub("q05cell_abundance_w_sf_", "", colnames(temp1.cel2))
  
  # Normalize cell type proportion so that the proportion adds up to 1
  temp1.cell2 <- rowSums(temp1.cel2[,-1]) %>% as.data.frame() %>% 'colnames<-' ("RowSum")
  temp1.cell2$X <- temp1.cel2$X
  for (k in 2:ncol(temp1.cel2)) {
    temp1.cell2[,k+1] <- temp1.cel2[,k] / temp1.cell2$RowSum
    colnames(temp1.cell2)[k+1] <- colnames(temp1.cel2)[k]
  }
  temp1.cel2 <- temp1.cell2[,-1]
  region <- gsub("BCSA3", "", i)
  temp1.cel2$X <- paste0(region, "_", temp1.cel2$X)
  temp1 <- rbind(temp1, temp1.cel2)
}

# Aggregate epithelial clusters
temp1$epithelial <- rowSums(temp1[which(str_detect(colnames(temp1), 
                                      "Cancer|Mature.Luminal|Luminal.Progenitors|Myoepithelial"))])

# Filter out spots does not have 20% of epithelial
temp1_filtered <- temp1[which(temp1$epithelial > 0.2), ]

pam50 <- bcsa3_pam50@meta.data$subtypecd_aims
names(pam50) <- rownames(bcsa3_pam50@meta.data)

# Keep spots that are only used in the clustering and with at least 20% of epithelial cells
pam50 <- pam50[which(names(pam50) %in% temp1_filtered$X)]
pam50 <- pam50[which(names(pam50) %in% colnames(bcsa3))]

bcsa3_pam50 <- bcsa3
bcsa3_pam50 <- AddMetaData(bcsa3_pam50, pam50, col.name = "PAM50_aims")

# Subset the seurat object
temp1_filtered <- temp1_filtered[which(temp1_filtered$X %in% colnames(bcsa3)),]
bcsa3_pam50 <- subset(bcsa3_pam50, cells = temp1_filtered$X)

# Filter out spots without tumor based on QuPath annotation
ref <- read.delim("/Users/tili/Desktop/CIIR/results/infercnv/BCSA3_ref_spot.txt", header = F)
temp1_tumor <- temp1_filtered[-which(temp1_filtered$X %in% ref$V1),]

# Subset the seurat object
bcsa3_pam50 <- subset(bcsa3_pam50, cells = temp1_tumor$X)

col <- c("NBL" = "#66c530", "H2" = "#d4279c", "LA" = "#2a3188", "LB" = "#419ad2", "BL" = "#97191e")
SpatialDimPlot(bcsa3_pam50, group.by = "PAM50_aims", ncol = 4, cols = col) + 
  plot_layout(guides = "collect")

# Pie chart for PAM50 percent
df <- table(bcsa3_pam50@meta.data$PAM50_aims) %>% as.data.frame()
df$Total <- sum(df$Freq)
df$Percent <- df$Freq / df$Total

pie(df$Freq, labels = paste(df$Var1, round(df$Percent * 100, 2), "%"), 
    col = c("H2" = "#d4279c", "LA" = "#2a3188", "LB" = "#419ad2", "NBL" = "#66c530"), main = "BCSA3 PAM50")

############## Calculate the percentage of each cluster in each intrinsic subtype
meta <- bcsa3_pam50@meta.data %>% as.data.frame() 
cluster_freq <- meta %>% dplyr::group_by(PAM50_aims) %>% 
  dplyr::count(integrated_clusters)

cluster_freq <- cluster_freq %>% dplyr::group_by(PAM50_aims) %>% mutate(Total = sum(n))
cluster_freq$Percent <- cluster_freq$n / cluster_freq$Total

ggplot(cluster_freq, aes(x = PAM50_aims, y = Percent, fill = integrated_clusters)) + 
  geom_bar(stat = "identity", position = "stack") + theme_bw() +
  scale_fill_manual(values = c("0" = "#3C77AF",
        "1" = "#7DBFA7", "2" = "#EE934E", "4" = "#AECDE1",
        "3" = "#D1352B", "9" = "#F5CFE4", 
        "5" = "#FCED82", "7" = "#B383B9", "8" = "#BBDD78", "6" = "grey", "9" = "#429948", "10" = "#7A2C2C")) + xlab("") 

########## Plot the cell type percent from QuPath
qupath <- read.csv("/Users/tili/Desktop/CIIR/results/Cell_annotation_qupath_analyzed/cell_qupath_combined_20241014.csv")
qupath$spot <- paste0(str_sub(qupath$id, start = 6), "_", qupath$cellid)
qupath$patient <- str_sub(qupath$id, end = 5)

# Extract tumor spot id
spotid <- bcsa3_pam50@meta.data %>% as.data.frame()
spotid$X <- rownames(spotid)

bcsa3_filtered <- qupath[which(qupath$spot %in% spotid$X & qupath$patient == "BCSA3"),]
bcsa3_filtered <- merge(bcsa3_filtered, spotid, by.x = "spot", by.y = "X")

# Calculate the percent of tumor, immune, and stroma in intrinsic subtype
bcsa3_freq <- bcsa3_filtered %>% dplyr::group_by(PAM50_aims) %>% 
  dplyr::count(Classification) %>% 
  dplyr::filter(Classification != "")

bcsa3_freq <- bcsa3_freq %>% dplyr::group_by(PAM50_aims) %>% mutate(Total = sum(n))
bcsa3_freq$Percent <- bcsa3_freq$n / bcsa3_freq$Total

# Plot the cell type percent in each tumor cluster
ggplot(bcsa3_freq, aes(x = PAM50_aims, y = Percent, fill = Classification)) + 
  geom_bar(stat = "identity", position = "stack") + theme_bw() +
  scale_fill_manual(values = c("Tumor" = "#429948", 
          "Immune cells" = "#FFDE18", "Stroma" = "#9BCCE3")) + xlab("") 


```

## BCSA3TumA2 hormone receptor markers

```{r Receptor expression}

load("~/Desktop/CIIR/data/PAM50Bulk/results/BCSA3TumA2_processed.RData")

# Plot hormone receptors
SpatialFeaturePlot(bcsa, features = c("ESR1", "PGR", "ERBB2", "MKI67"), ncol = 4, keep.scale = "all")

```

## Import validation Xenium data

```{r import validation xenium data}

# Digital pathology annotation
dig <- read.delim("/Users/tili/Desktop/CIIR/results/Cell_annotation_qupath_analyzed/Cell_Xenium_V1_FFPE_Sample_2.txt")
dig$x <- dig$Centroid.X.µm
dig$y <- dig$Centroid.Y.µm

ima <- magick::image_read("/Users/tili/Desktop/CIIR/data/10x_dataset/Xenium_V1_FFPE_Preview_Human_Breast_Cancer_Sample_2_he_image.ome.tif")
image_in <- magick::image_info(ima)
width <- image_in$width
height <- image_in$height

dig$y_reverse <- height - dig$y
dig$x_reverse <- width - dig$x

p1 <- ggplot(dig, aes(x = x_reverse, y = y, col = Classification)) + geom_point(size = 0.01) + theme_bw() 
ggplotly(p1)

# Subset the dataset
d2 <- dig %>% dplyr::select(Classification, x_reverse, y)

# Load Xenium data
s2 <- LoadXenium(data.dir = "/Users/tili/Desktop/CIIR/data/10x_dataset/Xenium_FFPE_sample2/Xenium_V1_FFPE_Preview_Human_Breast_Cancer_Sample_2_outs/", fov = "fov", assay = "Xenium")

# Remove cells with 0 counts
s2 <- subset(s2, subset = nCount_Xenium > 0)

VlnPlot(s2, features = c("nFeature_Xenium", "nCount_Xenium"), ncol = 2, pt.size = 0)

# Check tumor, immune, and stroma markers
p2 <- ImageDimPlot(s2, molecules = c("PTPRC", "ERBB2", "PDGFRA"), nmols = 141828, cols = c("grey")) + theme_bw()
ggplotly(p2)

# Extract expression of markers and all the dots
dat <- p2[[1]]$data
mar <- p2[[1]]$layers[[2]]$data

# Rename colname for mar as x is y in the actual figure
colnames(mar)[1:2] <- c("y", "x")
colnames(dat)[2:3] <- c("y", "x")

ggplot(dat, aes(x = x, y = y)) + geom_point(size = 0.01) + theme_bw() 
ggplot(mar, aes(x = x, y = y, col = molecule)) + geom_point(size = 0.01) + theme_bw() 

# Scaling factor = 0.975, x_crop = 15757.8546, y_crop = 1495.13131
d2$x_crop <- (d2$x_reverse - 15707) / 0.99
d2$y_crop <- (d2$y - 1385) / 0.99

# Remove the dots outside the capture area
d3 <- d2 %>% dplyr::filter(!x_crop < 0) %>% dplyr::filter(!y_crop < 0)

# Plot to check the calculation
ggplot(d3, aes(x = x_crop, y = y_crop, col = Classification)) + geom_point(size = 0.01, alpha = 0.5) + theme_bw() +
  geom_point(mar, mapping = aes(x = x, y = y, col = molecule), size = 0.01)

# Tumor expression
tumor_qupath <- d3 %>% dplyr::filter(Classification == "Tumor")
tumor_xenium <- mar %>% dplyr::filter(molecule == "ERBB2")

# Calculate 15% of the number of rows
set.seed(123)  # Set seed for reproducibility
sample_size <- floor(0.15 * nrow(tumor_xenium))
tumor_xenium <- tumor_xenium[sample(nrow(tumor_xenium), sample_size), ]

p3 <- ggplot() + geom_point(tumor_xenium, mapping = aes(x = x, y = y), size = 0.01, col = "grey") + 
  theme_bw() + ggtitle("Xenium ERBB2 expression") + xlab("") + ylab("") + xlim(c(0, 5500))
p4 <- ggplot() + geom_point(tumor_qupath, mapping = aes(x = x_crop, y = y_crop), size = 0.01, col = "grey") + 
  theme_bw() + ggtitle("QuPath Tumor annotation") + xlab("") + ylab("") + xlim(c(0, 5500))
p3 + p4

# Immune expression
immune_qupath <- d3 %>% dplyr::filter(Classification == "Immune cells")
immune_xenium <- mar %>% dplyr::filter(molecule == "PTPRC")

# Calculate 50% of the number of rows
set.seed(123)  # Set seed for reproducibility
sample_size <- floor(0.5 * nrow(immune_xenium))
immune_xenium <- immune_xenium[sample(nrow(immune_xenium), sample_size), ]

p3 <- ggplot() + geom_point(immune_xenium, mapping = aes(x = x, y = y), size = 0.01, col = "grey") + 
  theme_bw() + ggtitle("Xenium PTPRC expression") + xlab("") + ylab("") + xlim(c(0, 5500))
p4 <- ggplot() + geom_point(immune_qupath, mapping = aes(x = x_crop, y = y_crop), size = 0.01, col = "grey") + 
  theme_bw() + ggtitle("QuPath Immune annotation") + xlab("") + ylab("") + xlim(c(0, 5500))
p3 + p4

# Stroma expression
stroma_qupath <- d3 %>% dplyr::filter(Classification == "Stroma")
stroma_xenium <- mar %>% dplyr::filter(molecule == "PDGFRA")

p3 <- ggplot() + geom_point(stroma_xenium, mapping = aes(x = x, y = y), size = 0.01, col = "grey") + 
  theme_bw() + ggtitle("Xenium PDGFRA expression") + xlab("") + ylab("") + xlim(c(0, 5500))
p4 <- ggplot() + geom_point(stroma_qupath, mapping = aes(x = x_crop, y = y_crop), size = 0.01, col = "grey") + 
  theme_bw() + ggtitle("QuPath Stroma annotation") + xlab("") + ylab("") + xlim(c(0, 5500))
p3 + p4

# Combined markers figure
xenium <- rbind(tumor_xenium, immune_xenium, stroma_xenium)
xenium$molecule <- factor(xenium$molecule, levels = c("ERBB2", "PDGFRA", "PTPRC"))

qupath <- rbind(tumor_qupath, immune_qupath, stroma_qupath)

p3 <- ggplot() + geom_point(xenium, mapping = aes(x = x, y = y, col = molecule), size = 0.01) + 
  theme_bw() + ggtitle("Xenium markers") + xlab("") + ylab("") + xlim(c(0, 5500)) +
  scale_color_manual(values = c("ERBB2" = "#429948", 
         "PTPRC" = "#FFDE18", "PDGFRA" = "#9BCCE3"))
p4 <- ggplot() + geom_point(qupath, mapping = aes(x = x_crop, y = y_crop, col = Classification), size = 0.01) + 
  theme_bw() + ggtitle("QuPath annotation") + xlab("") + ylab("") + xlim(c(0, 5500)) +
  scale_color_manual(values = c("Tumor" = "#429948", 
         "Immune cells" = "#FFDE18", "Stroma" = "#9BCCE3"))
p3 + p4

```

## Get spots without tumor cells from QuPath for inferCNV

```{r Ref spots for inferCNV}

info <- openxlsx::read.xlsx("~/Desktop/CIIR/data/ST-AR_Visium_samples_with file names.xlsx") %>% na.omit()
info$id <- paste0(info$Patientid, info$Tumor.area)
info <- info[-which(info$id == "BCSA2TumA1"), ]
info <- info[-which(info$id == "BCSA2TumA2"), ]

BCSA1_ref <- character()
BCSA2_ref <- character()
BCSA3_ref <- character()
for (i in 1:nrow(info)) {
  patient <- info$Patientid[i]
  id <- info$id[i]
  
  # Read qupath annotation and rename spot ID
  temp1 <- read.csv(paste0("/Users/tili/Desktop/CIIR/results/cell2location/Merged_correlation_results/",
                           id, "_correlation_matrix.csv"))
  temp1$X <- paste0(gsub(patient, "", id), "_", temp1$X)
  ref <- temp1[which(temp1$Tumor == 0),]$X
  
  # Combine the reference spots together
  if (patient == "BCSA1") {
    BCSA1_ref <- c(BCSA1_ref, ref)
  } else if (patient == "BCSA2") {
    BCSA2_ref <- c(BCSA2_ref, ref)
  } else if (patient == "BCSA3") {
    BCSA3_ref <- c(BCSA3_ref, ref)
  }
}

write.table(BCSA1_ref, file = "/Users/tili/Desktop/CIIR/results/infercnv/BCSA1_ref_spot.txt", 
            row.names = F, col.names = F)
write.table(BCSA2_ref, file = "/Users/tili/Desktop/CIIR/results/infercnv/BCSA2_ref_spot.txt", 
            row.names = F, col.names = F)
write.table(BCSA3_ref, file = "/Users/tili/Desktop/CIIR/results/infercnv/BCSA3_ref_spot.txt", 
            row.names = F, col.names = F)

########### Select spots with at least 40% tumor to run inferCNV, remove rep2

# BCSA1
decon <- data.frame()
for (i in names(bcsa1@images)) {
  temp1 <- read.csv(paste0("/Users/tili/Desktop/CIIR/results/cell2location/Merged_correlation_results/", 
                           i, "_correlation_matrix.csv"))
  region <- gsub("BCSA1", "", i)
  temp1$X <- paste0(region, "_", temp1$X)
  decon <- rbind(decon, temp1)
}

bcsa1_cnv_spot <- decon %>% dplyr::filter(tumor_per > 0.7)
bcsa1_cnv_spot$region <- str_sub(bcsa1_cnv_spot$X, end = 5)
bcsa1_cnv_spot <- bcsa1_cnv_spot %>% 
  dplyr::filter(region != "TumA2") %>% 
  dplyr::filter(region != "TumB2")

unique(bcsa1_cnv_spot$region)

write.table(bcsa1_cnv_spot$X, file = "/Users/tili/Desktop/CIIR/results/infercnv/BCSA1_filtered_tumor_70_percent_spots_rep1_for_inferCNV.txt", col.names = F, row.names = F)

# BCSA2
decon <- data.frame()
for (i in names(bcsa2@images)) {
  temp1 <- read.csv(paste0("/Users/tili/Desktop/CIIR/results/cell2location/Merged_correlation_results/", 
                           i, "_correlation_matrix.csv"))[,c(1:12)]
  region <- gsub("BCSA2", "", i)
  temp1$X <- paste0(region, "_", temp1$X)
  decon <- rbind(decon, temp1)
}

bcsa2_cnv_spot <- decon %>% dplyr::filter(tumor_per > 0.7)
bcsa2_cnv_spot$region <- str_sub(bcsa2_cnv_spot$X, end = 5)
bcsa2_cnv_spot <- bcsa2_cnv_spot %>% 
  dplyr::filter(region != "TumC2") %>% 
  dplyr::filter(region != "TumB2") %>% 
  dplyr::filter(region != "TumD2") %>% 
  dplyr::filter(region != "TumD3") %>% 
  dplyr::filter(region != "TumD4") %>% 
  dplyr::filter(region != "TumE2")

unique(bcsa2_cnv_spot$region)
write.table(bcsa2_cnv_spot$X, file = "/Users/tili/Desktop/CIIR/results/infercnv/BCSA2_filtered_tumor_70_percent_spots_rep1_for_inferCNV.txt", 
            col.names = F, row.names = F)

# BCSA3
decon <- data.frame()
gro <- names(bcsa3@images)[-4]
for (i in gro) {
  temp1 <- read.csv(paste0("/Users/tili/Desktop/CIIR/results/cell2location/Merged_correlation_results/", 
                           i, "_correlation_matrix.csv"))
  region <- gsub("BCSA3", "", i)
  temp1$X <- paste0(region, "_", temp1$X)
  decon <- rbind(decon, temp1)
}

bcsa3_cnv_spot <- decon %>% dplyr::filter(tumor_per > 0.7)
bcsa3_cnv_spot$region <- str_sub(bcsa3_cnv_spot$X, end = 5)
bcsa3_cnv_spot <- bcsa3_cnv_spot %>% 
  dplyr::filter(region != "TumA2") %>% 
  dplyr::filter(region != "TumB2") %>% 
  dplyr::filter(region != "TumC2") %>% 
  dplyr::filter(region != "TumD2") 
unique(bcsa3_cnv_spot$region)

write.table(bcsa3_cnv_spot$X, file = "/Users/tili/Desktop/CIIR/results/infercnv/BCSA3_filtered_tumor_70_percent_spots_rep1_for_inferCNV.txt", 
            col.names = F, row.names = F)

```

## BCSA2 SpatialVDJ plotting 

```{r SpatialVDJ and Quath}

vdj <- read_tsv("/Users/tili/Desktop/CIIR/data/SpatialVDJ_forZenodo/data/breast_cancer/1_LR-SpatialVDJ/postfiltered_matrices/newtables_run86-BC-SA2_TumE2-filtered-filter-readcount-0-umi-count.tsv")

meta <- read.csv("/Users/tili/Desktop/CIIR/data/SpatialVDJ_forZenodo/data/breast_cancer/1_LR-SpatialVDJ/clone_list/P1_all_ontissue_clone_list.csv")

# Fix the different name of ST barcodes
vdj$st_barcode <- paste0(vdj$st_barcode, "-1")

# Plot clone 0
clone0 <- vdj$'0'
names(clone0) <- vdj$st_barcode

e2 <- read.csv("~/Desktop/CIIR/results/cell2location/Merged_correlation_results/BCSA2TumE2_correlation_matrix.csv") %>% 
  dplyr::select(X, immune_cel2, stroma_cel2, tumor_cel2, col_30p, row_30p_reverse) 
e2$col <- e2$col_30p * 0.1370614
e2$row_reverse <- e2$row_30p_reverse * 0.1370614
e2$X <- paste0("TumE2_", e2$X)

clone_spot <- paste0("TumE2_", names(clone0[clone0 > 0]))
e2 <- e2[which(e2$X %in% clone_spot),]

# Add HE image on the back
ima <- magick::image_read("/Users/tili/Desktop/CIIR/data/visium_spatial_out/V10F24-114_D1/tissue_hires_image.png")
image_in <- magick::image_info(ima)
width <- image_in$width
height <- image_in$height

spots <- as.data.frame(clone0)
spots$spotid <- paste0("TumE2_", rownames(spots))
spots <- spots[which(spots$spotid %in% e2$X),]
e2 <- merge(e2, spots, by.x = "X", by.y = "spotid", all.x = T, all.y = T)

# Plot the visium spots
ggplot(e2, aes(y = row_reverse, x =col)) + 
  annotation_raster(ima, ymin = 0, ymax= height, xmin = 0, xmax = width) +
  geom_point(col = "#FFDE18") + theme_bw() + ylim(c(0, 1900)) + xlim(c(0, 1900))

# Merge Qupath cell level annotation with visium spot ID
i = 12
sampleid <- info$name[i]
# Get coordinates from Seurat object, 30p image was used to run spaceranger, which corresponding to the "full resolution" image 
patientid <- info$id[i]
load(paste0("/Users/tili/Desktop/CIIR/data/PAM50Bulk/results/", patientid, ".RData"))
df <- get(patientid, bcsa@images)
temp1.coor <- df@coordinates
temp1.coor$coor <- paste0(temp1.coor$imagerow, "x", temp1.coor$imagecol)
temp1.coor$cellid <- rownames(temp1.coor)

# Calculate the coordinate for full resolution image (30p image)
temp1.coor$row_30p <- temp1.coor$imagerow 
temp1.coor$col_30p <- temp1.coor$imagecol 

# Digital pathology was ran on the full resolution image from the microscope, thus has a scaling factor to 30p image
visium_h5ad_id <- info$Visum.h5ad.ID[i] %>% gsub("-Spot000001.h5ad", "", .)
d2 <- read.delim(paste0("/Users/tili/Desktop/CIIR/results/Cell_annotation_qupath_analyzed/Cell_", visium_h5ad_id, ".txt"))

# Get the full resolution image pixel number for scale factor calculation
width <- info$width[i]
height <- info$height[i]

# Calculate scale factor
ima <- magick::image_read(paste0("/Users/tili/Desktop/CIIR/data/BCSA_images/", visium_h5ad_id, "_30p.jpg"))
      
# Get the width and height of the image
image_in <- magick::image_info(ima)
width_30p <- image_in$width
height_30p <- image_in$height

# Use the height of the image to reverse the coordinates of y axis
temp1.coor$row_30p_reverse <- height_30p - temp1.coor$row_30p

scaling_factor <- height_30p / height

# Calculate the full resolution coordinates
temp1.coor$fullcol <- temp1.coor$col_30p / scaling_factor
temp1.coor$fullrow <- temp1.coor$row_30p / scaling_factor
  
# Extract radius from the scale.factor json file
r <- suppressWarnings(read.delim(paste0("/Users/tili/Desktop/CIIR/data/visium_spatial_out/", info$Visium.ID[i], "/scalefactors_json.json"), 
                  header = F)) %>% str_split(",", simplify = T)
r <- r[1] %>% str_split(": ", simplify = T)
r <- r[2] %>% as.numeric()
radius <- (r / 2) / scaling_factor
  
temp1.coor$fullrow_reverse <- height - temp1.coor$fullrow

# The pixel size for the tiff images was wrong, we manually changed to the correct one during annotation
# Therefore, we need to times a scaling factor to obtain the coordinates in pixels 
d2$x <- d2$Centroid.X.µm * 5.809
d2$y <- d2$Centroid.Y.µm * 5.809

d2$y_reverse <- height - d2$y

# Calculate the block coordinate for row and column, row is y axis, col is x axis
temp1.coor$ymin <- temp1.coor$fullrow_reverse - radius
temp1.coor$ymax <- temp1.coor$fullrow_reverse + radius
temp1.coor$xmin <- temp1.coor$fullcol - radius
temp1.coor$xmax <- temp1.coor$fullcol + radius

# If the cell falls in the square of the Visium capture area, then assign the cell id to the annotated cells
d2$cellid <- NA
for (j in 1:nrow(d2)) {
    x <- d2$x[j]
    y <- d2$y_reverse[j]
    temp4 <- temp1.coor[which(x > temp1.coor$xmin & x < temp1.coor$xmax & y > temp1.coor$ymin & y < temp1.coor$ymax), ]
    if (nrow(temp4) == 0) {
      d2$cellid[j] <- "Not_captured"
    } else {
      d2$cellid[j] <- temp4$cellid
    }
}

# Remove the cells not captured
d4 <- d2 %>% filter(cellid != "Not_captured")
d4$cellid <- paste0("TumE2_", d4$cellid)

# Filter out cells belong to spots with clone event
d5 <- d4[which(d4$cellid %in% e2$X),]
top2 <- spots %>% dplyr::arrange(spots$clone0) %>% tail(n = 2)

# Filter out two spots with the most clone events
d6 <- d5[which(d5$cellid %in% top2$spotid),]

# Plot the two selected spots on HE image
e2 %>% dplyr::filter(X %in% d6$cellid) %>% 
  ggplot(aes(y = row_reverse, x =col)) + 
  annotation_raster(ima, ymin = 0, ymax= height, xmin = 0, xmax = width) +
  geom_point(col = "#FFDE18") + theme_bw() + ylim(c(0, 1900)) + xlim(c(0, 1900))

# Save the objectID for qupath annotation
write.csv(d6, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA2TumE2_spatialVDJ_clone0_top2_event_spots_qupath_cell_annotation_output.csv")

```

## BCSA3 SpatialVDJ plotting 

```{r BCSA3 SpatialVDJ and Quath}

vdj <- read_tsv("/Users/tili/Desktop/CIIR/data/SpatialVDJ_forZenodo/data/breast_cancer/1_LR-SpatialVDJ/postfiltered_matrices/newtables_run86-BC-SA3_TumA1-filtered-filter-readcount-0-umi-count.tsv")

meta <- read.csv("/Users/tili/Desktop/CIIR/data/SpatialVDJ_forZenodo/data/breast_cancer/1_LR-SpatialVDJ/clone_list/P2_all_ontissue_clone_list.csv")

# Fix the different name of ST barcodes
vdj$st_barcode <- paste0(vdj$st_barcode, "-1")

# Plot clone 602
clone602 <- vdj$'602'
names(clone602) <- vdj$st_barcode

a1 <- read.csv("~/Desktop/CIIR/results/cell2location/Merged_correlation_results/BCSA3TumA1_correlation_matrix.csv") %>% 
  dplyr::select(X, immune_cel2, stroma_cel2, tumor_cel2, col_30p, row_30p_reverse) 
a1$col <- a1$col_30p * 0.1264143
a1$row_reverse <- a1$row_30p_reverse * 0.1264143
a1$X <- paste0("TumA1_", a1$X)

clone_spot <- paste0("TumA1_", names(clone602[clone602 > 0]))
a1 <- a1[which(a1$X %in% clone_spot),]

# Add HE image on the back
ima <- magick::image_read("/Users/tili/Desktop/CIIR/data/visium_spatial_out/V19T26-031_D1/tissue_hires_image.png")
image_in <- magick::image_info(ima)
width <- image_in$width
height <- image_in$height

spots <- as.data.frame(clone602)
spots$spotid <- paste0("TumA1_", rownames(spots))
spots <- spots[which(spots$spotid %in% a1$X),]
a1 <- merge(a1, spots, by.x = "X", by.y = "spotid", all.x = T, all.y = T)

# Plot the visium spots
ggplot(a1, aes(y = row_reverse, x =col)) + 
  annotation_raster(ima, ymin = 0, ymax = height, xmin = 0, xmax = width) +
  geom_point(col = "#FFDE18", size = 0.8) + theme_bw() + ylim(c(0, 1900)) + xlim(c(0, 1900))

# Merge Qupath cell level annotation with visium spot ID
i = 13
sampleid <- info$name[i]
# Get coordinates from Seurat object, 30p image was used to run spaceranger, which corresponding to the "full resolution" image 
patientid <- info$id[i]
load(paste0("/Users/tili/Desktop/CIIR/data/PAM50Bulk/results/", patientid, ".RData"))
df <- get(patientid, bcsa@images)
temp1.coor <- df@coordinates
temp1.coor$coor <- paste0(temp1.coor$imagerow, "x", temp1.coor$imagecol)
temp1.coor$cellid <- rownames(temp1.coor)

# Calculate the coordinate for full resolution image (30p image)
temp1.coor$row_30p <- temp1.coor$imagerow 
temp1.coor$col_30p <- temp1.coor$imagecol 

# Digital pathology was ran on the full resolution image from the microscope, thus has a scaling factor to 30p image
visium_h5ad_id <- info$Visum.h5ad.ID[i] %>% gsub("-Spot000001.h5ad", "", .)
d2 <- read.delim(paste0("/Users/tili/Desktop/CIIR/results/Cell_annotation_qupath_analyzed/Cell_", visium_h5ad_id, ".txt"))

# Get the full resolution image pixel number for scale factor calculation
width <- info$width[i]
height <- info$height[i]

# Calculate scale factor
ima <- magick::image_read(paste0("/Users/tili/Desktop/CIIR/data/BCSA_images/", visium_h5ad_id, "_30p.jpg"))
      
# Get the width and height of the image
image_in <- magick::image_info(ima)
width_30p <- image_in$width
height_30p <- image_in$height

# Use the height of the image to reverse the coordinates of y axis
temp1.coor$row_30p_reverse <- height_30p - temp1.coor$row_30p

scaling_factor <- height_30p / height

# Calculate the full resolution coordinates
temp1.coor$fullcol <- temp1.coor$col_30p / scaling_factor
temp1.coor$fullrow <- temp1.coor$row_30p / scaling_factor
  
# Extract radius from the scale.factor json file
r <- suppressWarnings(read.delim(paste0("/Users/tili/Desktop/CIIR/data/visium_spatial_out/", info$Visium.ID[i], "/scalefactors_json.json"), 
                  header = F)) %>% str_split(",", simplify = T)
r <- r[1] %>% str_split(": ", simplify = T)
r <- r[2] %>% as.numeric()
radius <- (r / 2) / scaling_factor
  
temp1.coor$fullrow_reverse <- height - temp1.coor$fullrow

# The pixel size for the tiff images was wrong, we manually changed to the correct one during annotation
# Therefore, we need to times a scaling factor to obtain the coordinates in pixels 
d2$x <- d2$Centroid.X.µm * 5.809
d2$y <- d2$Centroid.Y.µm * 5.809

d2$y_reverse <- height - d2$y

# Calculate the block coordinate for row and column, row is y axis, col is x axis
temp1.coor$ymin <- temp1.coor$fullrow_reverse - radius
temp1.coor$ymax <- temp1.coor$fullrow_reverse + radius
temp1.coor$xmin <- temp1.coor$fullcol - radius
temp1.coor$xmax <- temp1.coor$fullcol + radius

# If the cell falls in the square of the Visium capture area, then assign the cell id to the annotated cells
d2$cellid <- NA
for (j in 1:nrow(d2)) {
    x <- d2$x[j]
    y <- d2$y_reverse[j]
    temp4 <- temp1.coor[which(x > temp1.coor$xmin & x < temp1.coor$xmax & y > temp1.coor$ymin & y < temp1.coor$ymax), ]
    if (nrow(temp4) == 0) {
      d2$cellid[j] <- "Not_captured"
    } else {
      d2$cellid[j] <- temp4$cellid
    }
}

# Remove the cells not captured
d4 <- d2 %>% filter(cellid != "Not_captured")
d4$cellid <- paste0("TumA1_", d4$cellid)

# Filter out cells belong to spots with clone event
d5 <- d4[which(d4$cellid %in% a1$X),]
top2 <- spots %>% dplyr::arrange(spots$clone61) %>% tail(n = 2)

# Filter out two spots with the most clone events
d6 <- d5[which(d5$cellid %in% top2$spotid),]

ima <- magick::image_read("/Users/tili/Desktop/CIIR/data/visium_spatial_out/V19T26-031_D1/tissue_hires_image.png")
image_in <- magick::image_info(ima)
width <- image_in$width
height <- image_in$height

# Plot the selected spot on HE image (clone61: TumA1_GCTGCACGGTTTCTTA-1; clone602: TumA1_AAGGTGATAAACCAGC-1)
a1 %>% dplyr::filter(X == "TumA1_AAGGTGATAAACCAGC-1") %>% 
  ggplot(aes(y = row_reverse, x =col)) + 
  annotation_raster(ima, ymin = 0, ymax= height, xmin = 0, xmax = width) +
  geom_point(col = "#FFDE18") + theme_bw() + ylim(c(0, 1900)) + xlim(c(0, 1900))

# Save the objectID for qupath annotation
write.csv(d6, file = "/Users/tili/Desktop/CIIR/results/tables/BCSA3TumA1_spatialVDJ_T_cells_clone602_event_spots_qupath_cell_annotation_output.csv")

```

## Deconvolution for selected spots with VDJ clones

```{r Deconvolution for VDJ clones}

############### BCSA2TumE2 - Clone0: TumE2_ACACCACATAATTAGC-1

e2 <- read.csv("/Users/tili/Desktop/CIIR/results/cell2location/BCSA2TumE2_q05.csv")
colnames(e2) <- gsub("q05cell_abundance_w_sf_", "", colnames(e2))

# Aggregate to major level
e2$Endothelial <- rowSums(e2[which(str_detect(colnames(e2), 
                               "Endothelial"))])
e2$CAFs <- rowSums(e2[which(str_detect(colnames(e2), 
                               "CAF"))])
e2$PVLs <- rowSums(e2[which(str_detect(colnames(e2), 
                                      "PVL|Cycling.PVL"))])
e2$Cancer <- rowSums(e2[which(str_detect(colnames(e2), 
                                      "Cancer"))])
e2$B.cells <- rowSums(e2[which(str_detect(colnames(e2), 
                                      "B.cells"))])
e2$T.cells_ILCs <- rowSums(e2[which(str_detect(colnames(e2), 
                                      "T.cells|NK"))])
e2$Plasmablasts <- rowSums(e2[which(str_detect(colnames(e2), 
                                      "Plasmablasts"))])
e2$Myeloid <- rowSums(e2[which(str_detect(colnames(e2), 
                                      "DCs|Monocyte|Macrophage|Cycling_Myeloid"))])

e2_agg <- e2[,c(1, 28, 31:37)]

e2 <- e2_agg %>% dplyr::filter(X == "ACACCACATAATTAGC-1") %>% 
  pivot_longer(!X, names_to = "Celltype", values_to = "Abundance")

# Calculate normalized cell percentage
e2$Total <- sum(e2$Abundance)
e2$Percent <- e2$Abundance / e2$Total

# Plot percent as pie chart
pie(e2$Percent, labels = paste(e2$Celltype, round(e2$Percent * 100, 2), "%"), 
    col = c("#FEBD85", "#8DBAD9", "#DCDD8F", "#E99092", "#8ADDE4", "#C4A9A2", "#45AB84", "#1975BA"), 
    main = "B cell Clone0",
    cex = 0.8)

############### BCSA3TumA1 - Clone61: TumA1_GCTGCACGGTTTCTTA-1 (Clone602: TumA1_AAGGTGATAAACCAGC-1)

a1 <- read.csv("/Users/tili/Desktop/CIIR/results/cell2location/BCSA3TumA1_q05.csv")
colnames(a1) <- gsub("q05cell_abundance_w_sf_", "", colnames(a1))

# Aggregate to major level
a1$Endothelial <- rowSums(a1[which(str_detect(colnames(a1), 
                               "Endothelial"))])
a1$CAFs <- rowSums(a1[which(str_detect(colnames(a1), 
                               "CAF"))])
a1$PVLs <- rowSums(a1[which(str_detect(colnames(a1), 
                                      "PVL|Cycling.PVL"))])
a1$Cancer <- rowSums(a1[which(str_detect(colnames(a1), 
                                      "Cancer"))])
a1$B.cells <- rowSums(a1[which(str_detect(colnames(a1), 
                                      "B.cells"))])
a1$T.cells_ILCs <- rowSums(a1[which(str_detect(colnames(a1), 
                                      "T.cells|NK"))])
a1$Plasmablasts <- rowSums(a1[which(str_detect(colnames(a1), 
                                      "Plasmablasts"))])
a1$Myeloid <- rowSums(a1[which(str_detect(colnames(a1), 
                                      "DCs|Monocyte|Macrophage|Cycling_Myeloid"))])

a1_agg <- a1[,c(1, 28, 31:37)]

a1 <- a1_agg %>% dplyr::filter(X == "AAGGTGATAAACCAGC-1") %>% 
  pivot_longer(!X, names_to = "Celltype", values_to = "Abundance")

# Calculate normalized cell percentage
a1$Total <- sum(a1$Abundance)
a1$Percent <- a1$Abundance / a1$Total

# Plot percent as pie chart
pie(a1$Percent, labels = paste(a1$Celltype, round(a1$Percent * 100, 2), "%"), 
    col = c("#FEBD85", "#8DBAD9", "#DCDD8F", "#E99092", "#8ADDE4", "#C4A9A2", "#45AB84", "#1975BA"), 
    main = "T cell Clone602",
    cex = 0.8)

```

## session info

```{r session info}
sessionInfo()
```

